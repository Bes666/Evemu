/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "Manufacturing.h"
#include "../common/PyRep.h"




Call_GetJobs2::Call_GetJobs2() {
	ownerID = 0;
	completed = false;
	fromDate = 0;
	toDate = 0;
}

Call_GetJobs2::~Call_GetJobs2() {
}

void Call_GetJobs2::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetJobs2", pfx);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%scompleted=%s", pfx, completed?"true":"false");
	_log(l_type, "%sfromDate=" I64u, pfx, fromDate);
	_log(l_type, "%stoDate=" I64u, pfx, toDate);
}

PyRepTuple *Call_GetJobs2::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	tuple0->items[0] = new PyRepInteger(ownerID);
	tuple0->items[1] = new PyRepBoolean(completed);
	if(fromDate == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(fromDate);
	}
	if(toDate == -1) {
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = new PyRepInteger(toDate);
	}
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetJobs2::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	tuple0->items[0] = new PyRepInteger(ownerID);
	tuple0->items[1] = new PyRepBoolean(completed);
	if(fromDate == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(fromDate);
	}
	if(toDate == -1) {
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = new PyRepInteger(toDate);
	}
	res = tuple0;
	

	return(res);
}

bool Call_GetJobs2::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetJobs2::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: tuple0 is the wrong size: expected 4, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: ownerID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJobs2: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: completed is not a boolean: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_2 = (PyRepBoolean *) tuple0->items[1];
	completed = bool_2->value;
	if(tuple0->items[2]->CheckType(PyRep::None)) {
		fromDate = 0;
	} else {
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: fromDate is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) tuple0->items[2];
	fromDate = int64_3->value;
	}
	if(tuple0->items[3]->CheckType(PyRep::None)) {
		toDate = -1;
	} else {
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJobs2 failed: toDate is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple0->items[3];
	toDate = int64_4->value;
	}

	delete packet;
	return(true);
}

Call_GetJobs2 *Call_GetJobs2::Clone() const {
	Call_GetJobs2 *res = new Call_GetJobs2;
	res->CloneFrom(this);
	return(res);
}

void Call_GetJobs2::CloneFrom(const Call_GetJobs2 *from) {
	ownerID = from->ownerID;
	completed = from->completed;
	fromDate = from->fromDate;
	toDate = from->toDate;
	
}


Call_AssemblyLinesSelect::Call_AssemblyLinesSelect() {
	filter = "";
}

Call_AssemblyLinesSelect::~Call_AssemblyLinesSelect() {
}

void Call_AssemblyLinesSelect::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_AssemblyLinesSelect", pfx);
	_log(l_type, "%sfilter='%s'", pfx, filter.c_str());
}

PyRepTuple *Call_AssemblyLinesSelect::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepString(filter);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_AssemblyLinesSelect::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = new PyRepString(filter);
	res = tuple0;
	

	return(res);
}

bool Call_AssemblyLinesSelect::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_AssemblyLinesSelect::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssemblyLinesSelect failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_AssemblyLinesSelect failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssemblyLinesSelect failed: filter is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	filter = string_1->value;

	delete packet;
	return(true);
}

Call_AssemblyLinesSelect *Call_AssemblyLinesSelect::Clone() const {
	Call_AssemblyLinesSelect *res = new Call_AssemblyLinesSelect;
	res->CloneFrom(this);
	return(res);
}

void Call_AssemblyLinesSelect::CloneFrom(const Call_AssemblyLinesSelect *from) {
	filter = from->filter;
	
}


PathElement::PathElement() {
	locationID = 0;
	ownerID = 0;
	flag = 0;
}

PathElement::~PathElement() {
}

void PathElement::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sPathElement", pfx);
	_log(l_type, "%slocationID=%lu", pfx, locationID);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%sflag=%lu", pfx, flag);
}

PyRepList *PathElement::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(3, NULL);
	list0->items[0] = new PyRepInteger(locationID);
	list0->items[1] = new PyRepInteger(ownerID);
	list0->items[2] = new PyRepInteger(flag);
	res = list0;
	

	return(res);
}

PyRepList *PathElement::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(3, NULL);
	list0->items[0] = new PyRepInteger(locationID);
	list0->items[1] = new PyRepInteger(ownerID);
	list0->items[2] = new PyRepInteger(flag);
	res = list0;
	

	return(res);
}

bool PathElement::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool PathElement::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode PathElement failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode PathElement failed: list0 is the wrong size: expected 3, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode PathElement failed: locationID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode PathElement: truncating 64 bit into into 32 bit int for field locationID");
	}
	locationID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode PathElement failed: ownerID is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode PathElement: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode PathElement failed: flag is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode PathElement: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_3->value;

	delete packet;
	return(true);
}

PathElement *PathElement::Clone() const {
	PathElement *res = new PathElement;
	res->CloneFrom(this);
	return(res);
}

void PathElement::CloneFrom(const PathElement *from) {
	locationID = from->locationID;
	ownerID = from->ownerID;
	flag = from->flag;
	
}


Call_InstallJob::Call_InstallJob() {
	/*  installationLocationData  */
	/*  invLocation  */
	installationInvLocationID = 0;
	installationInvLocationGroupID = 0;
	installationContainerID = 0;
	installationAssemblyLineID = 0;
	/*  installedItemLocationData  */
	/*  invLocation  */
	installedItemInvLocationID = 0;
	installedItemInvLocationGroup = 0;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	/*  itemSpecification  */
	installedItemID = 0;
	/*  bomLocationData  */
	/*  invLocation  */
	bomInvLocationID = 0;
	bomInvLocationGroup = 0;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	flagOutput = 0;
	runs = 0;
	activityID = 0;
	licensedProductionRuns = 0;
	isCorpJob = false;
	description = "";
}

Call_InstallJob::~Call_InstallJob() {
	/*  installationLocationData  */
	/*  invLocation  */
	/*  installedItemLocationData  */
	/*  invLocation  */
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	/*  itemSpecification  */
	/*  bomLocationData  */
	/*  invLocation  */
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
}

void Call_InstallJob::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_InstallJob", pfx);
	/*  installationLocationData  */
	/*  invLocation  */
	_log(l_type, "%sinstallationInvLocationID=%lu", pfx, installationInvLocationID);
	_log(l_type, "%sinstallationInvLocationGroupID=%lu", pfx, installationInvLocationGroupID);
	_log(l_type, "%sinstallationContainerID=%lu", pfx, installationContainerID);
	_log(l_type, "%sinstallationAssemblyLineID=%lu", pfx, installationAssemblyLineID);
	/*  installedItemLocationData  */
	/*  invLocation  */
	_log(l_type, "%sinstalledItemInvLocationID=%lu", pfx, installedItemInvLocationID);
	_log(l_type, "%sinstalledItemInvLocationGroup=%lu", pfx, installedItemInvLocationGroup);
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	_log(l_type, "%sinstalledItemPath: ", pfx);
	std::string installedItemPath_n(pfx);
	installedItemPath_n += "    ";
	installedItemPath.Dump(l_type, installedItemPath_n.c_str());
	/*  itemSpecification  */
	_log(l_type, "%sinstalledItemID=%lu", pfx, installedItemID);
	/*  bomLocationData  */
	/*  invLocation  */
	_log(l_type, "%sbomInvLocationID=%lu", pfx, bomInvLocationID);
	_log(l_type, "%sbomInvLocationGroup=%lu", pfx, bomInvLocationGroup);
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	_log(l_type, "%sbomPath: ", pfx);
	std::string bomPath_n(pfx);
	bomPath_n += "    ";
	bomPath.Dump(l_type, bomPath_n.c_str());
	_log(l_type, "%sflagOutput=%lu", pfx, flagOutput);
	_log(l_type, "%sruns=%lu", pfx, runs);
	_log(l_type, "%sactivityID=%lu", pfx, activityID);
	_log(l_type, "%slicensedProductionRuns=%lu", pfx, licensedProductionRuns);
	_log(l_type, "%sisCorpJob=%s", pfx, isCorpJob?"true":"false");
	_log(l_type, "%sdescription='%s'", pfx, description.c_str());
}

PyRepTuple *Call_InstallJob::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(9);
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	/*  installationLocationData  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(2, NULL);
	/*  invLocation  */
	list2->items[0] = new PyRepInteger(installationInvLocationID);
	list2->items[1] = new PyRepInteger(installationInvLocationGroupID);
	list1->items[0] = list2;
	
	PyRepList *list3 = new PyRepList();
	list3->items.resize(0, NULL);
	list1->items[1] = list3;
	
	PyRepList *list4 = new PyRepList();
	list4->items.resize(2, NULL);
	list4->items[0] = new PyRepInteger(installationContainerID);
	list4->items[1] = new PyRepInteger(installationAssemblyLineID);
	list1->items[2] = list4;
	
	tuple0->items[0] = list1;
	
	PyRepList *list5 = new PyRepList();
	list5->items.resize(3, NULL);
	/*  installedItemLocationData  */
	PyRepList *list6 = new PyRepList();
	list6->items.resize(2, NULL);
	/*  invLocation  */
	list6->items[0] = new PyRepInteger(installedItemInvLocationID);
	list6->items[1] = new PyRepInteger(installedItemInvLocationGroup);
	list5->items[0] = list6;
	
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	list5->items[1] = installedItemPath.Clone();
	PyRepList *list7 = new PyRepList();
	list7->items.resize(1, NULL);
	/*  itemSpecification  */
	list7->items[0] = new PyRepInteger(installedItemID);
	list5->items[2] = list7;
	
	tuple0->items[1] = list5;
	
	PyRepList *list8 = new PyRepList();
	list8->items.resize(3, NULL);
	/*  bomLocationData  */
	PyRepList *list9 = new PyRepList();
	list9->items.resize(2, NULL);
	/*  invLocation  */
	list9->items[0] = new PyRepInteger(bomInvLocationID);
	list9->items[1] = new PyRepInteger(bomInvLocationGroup);
	list8->items[0] = list9;
	
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	list8->items[1] = bomPath.Clone();
	PyRepList *list10 = new PyRepList();
	list10->items.resize(0, NULL);
	list8->items[2] = list10;
	
	tuple0->items[2] = list8;
	
	tuple0->items[3] = new PyRepInteger(flagOutput);
	tuple0->items[4] = new PyRepInteger(runs);
	tuple0->items[5] = new PyRepInteger(activityID);
	tuple0->items[6] = new PyRepInteger(licensedProductionRuns);
	tuple0->items[7] = new PyRepBoolean(isCorpJob);
	tuple0->items[8] = new PyRepString(description);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_InstallJob::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(9);
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	/*  installationLocationData  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(2, NULL);
	/*  invLocation  */
	list2->items[0] = new PyRepInteger(installationInvLocationID);
	list2->items[1] = new PyRepInteger(installationInvLocationGroupID);
	list1->items[0] = list2;
	
	PyRepList *list3 = new PyRepList();
	list3->items.resize(0, NULL);
	list1->items[1] = list3;
	
	PyRepList *list4 = new PyRepList();
	list4->items.resize(2, NULL);
	list4->items[0] = new PyRepInteger(installationContainerID);
	list4->items[1] = new PyRepInteger(installationAssemblyLineID);
	list1->items[2] = list4;
	
	tuple0->items[0] = list1;
	
	PyRepList *list5 = new PyRepList();
	list5->items.resize(3, NULL);
	/*  installedItemLocationData  */
	PyRepList *list6 = new PyRepList();
	list6->items.resize(2, NULL);
	/*  invLocation  */
	list6->items[0] = new PyRepInteger(installedItemInvLocationID);
	list6->items[1] = new PyRepInteger(installedItemInvLocationGroup);
	list5->items[0] = list6;
	
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	
	PyRepList *list7 = new PyRepList();
	list7->items = installedItemPath.items;
	installedItemPath.items.clear();
	list5->items[1] = list7;
	PyRepList *list8 = new PyRepList();
	list8->items.resize(1, NULL);
	/*  itemSpecification  */
	list8->items[0] = new PyRepInteger(installedItemID);
	list5->items[2] = list8;
	
	tuple0->items[1] = list5;
	
	PyRepList *list9 = new PyRepList();
	list9->items.resize(3, NULL);
	/*  bomLocationData  */
	PyRepList *list10 = new PyRepList();
	list10->items.resize(2, NULL);
	/*  invLocation  */
	list10->items[0] = new PyRepInteger(bomInvLocationID);
	list10->items[1] = new PyRepInteger(bomInvLocationGroup);
	list9->items[0] = list10;
	
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	
	PyRepList *list11 = new PyRepList();
	list11->items = bomPath.items;
	bomPath.items.clear();
	list9->items[1] = list11;
	PyRepList *list12 = new PyRepList();
	list12->items.resize(0, NULL);
	list9->items[2] = list12;
	
	tuple0->items[2] = list9;
	
	tuple0->items[3] = new PyRepInteger(flagOutput);
	tuple0->items[4] = new PyRepInteger(runs);
	tuple0->items[5] = new PyRepInteger(activityID);
	tuple0->items[6] = new PyRepInteger(licensedProductionRuns);
	tuple0->items[7] = new PyRepBoolean(isCorpJob);
	tuple0->items[8] = new PyRepString(description);
	res = tuple0;
	

	return(res);
}

bool Call_InstallJob::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_InstallJob::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 9) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: tuple0 is the wrong size: expected 9, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list1 is the wrong size: expected 3, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  installationLocationData  */
	if(!list1->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list2 is not a list: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) list1->items[0];
	if(list2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list2 is the wrong size: expected 2, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	/*  invLocation  */
	if(!list2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installationInvLocationID is not an int: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installationInvLocationID");
	}
	installationInvLocationID = int_3->value;
	if(!list2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installationInvLocationGroupID is not an int: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installationInvLocationGroupID");
	}
	installationInvLocationGroupID = int_4->value;
	if(!list1->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list5 is not a list: %s", list1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) list1->items[1];
	if(list5->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list5 is the wrong size: expected 0, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	if(!list1->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list6 is not a list: %s", list1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list6 = (PyRepList *) list1->items[2];
	if(list6->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list6 is the wrong size: expected 2, but got %d", list6->items.size());
		delete packet;
		return(false);
	}

	if(!list6->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installationContainerID is not an int: %s", list6->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) list6->items[0];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installationContainerID");
	}
	installationContainerID = int_7->value;
	if(!list6->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installationAssemblyLineID is not an int: %s", list6->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list6->items[1];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installationAssemblyLineID");
	}
	installationAssemblyLineID = int_8->value;
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list9 is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list9 = (PyRepList *) tuple0->items[1];
	if(list9->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list9 is the wrong size: expected 3, but got %d", list9->items.size());
		delete packet;
		return(false);
	}

	/*  installedItemLocationData  */
	if(!list9->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list10 is not a list: %s", list9->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list10 = (PyRepList *) list9->items[0];
	if(list10->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list10 is the wrong size: expected 2, but got %d", list10->items.size());
		delete packet;
		return(false);
	}

	/*  invLocation  */
	if(!list10->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installedItemInvLocationID is not an int: %s", list10->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) list10->items[0];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installedItemInvLocationID");
	}
	installedItemInvLocationID = int_11->value;
	if(!list10->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installedItemInvLocationGroup is not an int: %s", list10->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) list10->items[1];
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installedItemInvLocationGroup");
	}
	installedItemInvLocationGroup = int_12->value;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	if(!list9->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installedItemPath is not a list: %s", list9->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_installedItemPath = (PyRepList *) list9->items[1];	installedItemPath.items = list_installedItemPath->items;
	list_installedItemPath->items.clear();
	
	if(!list9->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list13 is not a list: %s", list9->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list13 = (PyRepList *) list9->items[2];
	if(list13->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list13 is the wrong size: expected 1, but got %d", list13->items.size());
		delete packet;
		return(false);
	}

	/*  itemSpecification  */
	if(!list13->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: installedItemID is not an int: %s", list13->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_14 = (PyRepInteger *) list13->items[0];
	if(int_14->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field installedItemID");
	}
	installedItemID = int_14->value;
	if(!tuple0->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list15 is not a list: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list15 = (PyRepList *) tuple0->items[2];
	if(list15->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list15 is the wrong size: expected 3, but got %d", list15->items.size());
		delete packet;
		return(false);
	}

	/*  bomLocationData  */
	if(!list15->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list16 is not a list: %s", list15->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list16 = (PyRepList *) list15->items[0];
	if(list16->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list16 is the wrong size: expected 2, but got %d", list16->items.size());
		delete packet;
		return(false);
	}

	/*  invLocation  */
	if(!list16->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: bomInvLocationID is not an int: %s", list16->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_17 = (PyRepInteger *) list16->items[0];
	if(int_17->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field bomInvLocationID");
	}
	bomInvLocationID = int_17->value;
	if(!list16->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: bomInvLocationGroup is not an int: %s", list16->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_18 = (PyRepInteger *) list16->items[1];
	if(int_18->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field bomInvLocationGroup");
	}
	bomInvLocationGroup = int_18->value;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	if(!list15->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: bomPath is not a list: %s", list15->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_bomPath = (PyRepList *) list15->items[1];	bomPath.items = list_bomPath->items;
	list_bomPath->items.clear();
	
	if(!list15->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list19 is not a list: %s", list15->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list19 = (PyRepList *) list15->items[2];
	if(list19->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: list19 is the wrong size: expected 0, but got %d", list19->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: flagOutput is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_20 = (PyRepInteger *) tuple0->items[3];
	if(int_20->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field flagOutput");
	}
	flagOutput = int_20->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: runs is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_21 = (PyRepInteger *) tuple0->items[4];
	if(int_21->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field runs");
	}
	runs = int_21->value;
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: activityID is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_22 = (PyRepInteger *) tuple0->items[5];
	if(int_22->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field activityID");
	}
	activityID = int_22->value;
	if(!tuple0->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: licensedProductionRuns is not an int: %s", tuple0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_23 = (PyRepInteger *) tuple0->items[6];
	if(int_23->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_InstallJob: truncating 64 bit into into 32 bit int for field licensedProductionRuns");
	}
	licensedProductionRuns = int_23->value;
	if(!tuple0->items[7]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: isCorpJob is not a boolean: %s", tuple0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_24 = (PyRepBoolean *) tuple0->items[7];
	isCorpJob = bool_24->value;
	if(!tuple0->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_InstallJob failed: description is not a string: %s", tuple0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_25 = (PyRepString *) tuple0->items[8];
	description = string_25->value;

	delete packet;
	return(true);
}

Call_InstallJob *Call_InstallJob::Clone() const {
	Call_InstallJob *res = new Call_InstallJob;
	res->CloneFrom(this);
	return(res);
}

void Call_InstallJob::CloneFrom(const Call_InstallJob *from) {
	/*  installationLocationData  */
	/*  invLocation  */
	installationInvLocationID = from->installationInvLocationID;
	installationInvLocationGroupID = from->installationInvLocationGroupID;
	installationContainerID = from->installationContainerID;
	installationAssemblyLineID = from->installationAssemblyLineID;
	/*  installedItemLocationData  */
	/*  invLocation  */
	installedItemInvLocationID = from->installedItemInvLocationID;
	installedItemInvLocationGroup = from->installedItemInvLocationGroup;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	installedItemPath.CloneFrom(&from->installedItemPath);
	/*  itemSpecification  */
	installedItemID = from->installedItemID;
	/*  bomLocationData  */
	/*  invLocation  */
	bomInvLocationID = from->bomInvLocationID;
	bomInvLocationGroup = from->bomInvLocationGroup;
	/*  List of PathElements, there is 1 on personal job, 3 on corp job  */
	bomPath.CloneFrom(&from->bomPath);
	flagOutput = from->flagOutput;
	runs = from->runs;
	activityID = from->activityID;
	licensedProductionRuns = from->licensedProductionRuns;
	isCorpJob = from->isCorpJob;
	description = from->description;
	
}


MaterialList::MaterialList() {
	/* object of type util.Rowset */
	header_requiredTypeID = "requiredTypeID";
	header_quantity = "quantity";
	header_damagePerJob = "damagePerJob";
	header_isSkillCheck = "isSkillCheck";
	header_requiresHP = "requiresHP";
	RowClass = "util.Row";
}

MaterialList::~MaterialList() {
}

void MaterialList::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sMaterialList", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%sheader_requiredTypeID='%s'", pfx, header_requiredTypeID.c_str());
	_log(l_type, "%sheader_quantity='%s'", pfx, header_quantity.c_str());
	_log(l_type, "%sheader_damagePerJob='%s'", pfx, header_damagePerJob.c_str());
	_log(l_type, "%sheader_isSkillCheck='%s'", pfx, header_isSkillCheck.c_str());
	_log(l_type, "%sheader_requiresHP='%s'", pfx, header_requiresHP.c_str());
	_log(l_type, "%sRowClass='%s'", pfx, RowClass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *MaterialList::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(header_requiredTypeID);
	list2->items[1] = new PyRepString(header_quantity);
	list2->items[2] = new PyRepString(header_damagePerJob);
	list2->items[3] = new PyRepString(header_isSkillCheck);
	list2->items[4] = new PyRepString(header_requiresHP);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(RowClass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

PyRepObject *MaterialList::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(header_requiredTypeID);
	list2->items[1] = new PyRepString(header_quantity);
	list2->items[2] = new PyRepString(header_damagePerJob);
	list2->items[3] = new PyRepString(header_isSkillCheck);
	list2->items[4] = new PyRepString(header_requiresHP);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(RowClass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	
	PyRepList *list3 = new PyRepList();
	list3->items = lines.items;
	lines.items.clear();
	dict1_2 = list3;
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool MaterialList::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool MaterialList::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_RowClass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode MaterialList failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: header_requiredTypeID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	header_requiredTypeID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: header_quantity is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	header_quantity = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: header_damagePerJob is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	header_damagePerJob = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: header_isSkillCheck is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	header_isSkillCheck = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: header_requiresHP is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	header_requiresHP = string_7->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_RowClass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: RowClass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) dict1_cur->second;
	RowClass = string_8->value;
	if(string_8->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode MaterialList: String type mismatch on RowClass: expected %d got %d. Continuing anyhow.", true, string_8->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode MaterialList failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_RowClass) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: Missing dict entry for 'RowClass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode MaterialList failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

MaterialList *MaterialList::Clone() const {
	MaterialList *res = new MaterialList;
	res->CloneFrom(this);
	return(res);
}

void MaterialList::CloneFrom(const MaterialList *from) {
	/* object of type util.Rowset */
	header_requiredTypeID = from->header_requiredTypeID;
	header_quantity = from->header_quantity;
	header_damagePerJob = from->header_damagePerJob;
	header_isSkillCheck = from->header_isSkillCheck;
	header_requiresHP = from->header_requiresHP;
	RowClass = from->RowClass;
	lines.CloneFrom(&from->lines);
	
}


MaterialList_Line::MaterialList_Line() {
	requiredTypeID = 0;
	quantity = 0;
	damagePerJob = 0.0;
	isSkillCheck = 0;
	requiresHP = false;
}

MaterialList_Line::~MaterialList_Line() {
}

void MaterialList_Line::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sMaterialList_Line", pfx);
	_log(l_type, "%srequiredTypeID=%lu", pfx, requiredTypeID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sdamagePerJob=%.13f", pfx, damagePerJob);
	_log(l_type, "%sisSkillCheck=%lu", pfx, isSkillCheck);
	_log(l_type, "%srequiresHP=%s", pfx, requiresHP?"true":"false");
}

PyRepList *MaterialList_Line::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(requiredTypeID);
	list0->items[1] = new PyRepInteger(quantity);
	list0->items[2] = new PyRepReal(damagePerJob);
	list0->items[3] = new PyRepInteger(isSkillCheck);
	list0->items[4] = new PyRepBoolean(requiresHP);
	res = list0;
	

	return(res);
}

PyRepList *MaterialList_Line::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(requiredTypeID);
	list0->items[1] = new PyRepInteger(quantity);
	list0->items[2] = new PyRepReal(damagePerJob);
	list0->items[3] = new PyRepInteger(isSkillCheck);
	list0->items[4] = new PyRepBoolean(requiresHP);
	res = list0;
	

	return(res);
}

bool MaterialList_Line::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool MaterialList_Line::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: list0 is the wrong size: expected 5, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: requiredTypeID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode MaterialList_Line: truncating 64 bit into into 32 bit int for field requiredTypeID");
	}
	requiredTypeID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: quantity is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode MaterialList_Line: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: damagePerJob is not a real: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) list0->items[2];
	damagePerJob = real_3->value;
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: isSkillCheck is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode MaterialList_Line: truncating 64 bit into into 32 bit int for field isSkillCheck");
	}
	isSkillCheck = int_4->value;
	if(!list0->items[4]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode MaterialList_Line failed: requiresHP is not a boolean: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_5 = (PyRepBoolean *) list0->items[4];
	requiresHP = bool_5->value;

	delete packet;
	return(true);
}

MaterialList_Line *MaterialList_Line::Clone() const {
	MaterialList_Line *res = new MaterialList_Line;
	res->CloneFrom(this);
	return(res);
}

void MaterialList_Line::CloneFrom(const MaterialList_Line *from) {
	requiredTypeID = from->requiredTypeID;
	quantity = from->quantity;
	damagePerJob = from->damagePerJob;
	isSkillCheck = from->isSkillCheck;
	requiresHP = from->requiresHP;
	
}


BillOfMaterials::BillOfMaterials() {
	/* object of type util.Row */
	header_rawMaterials = "rawMaterials";
	header_extras = "extras";
	header_wasteMaterials = "wasteMaterials";
	header_skills = "skills";
}

BillOfMaterials::~BillOfMaterials() {
	std::map<uint32, PyRep *>::iterator skills_cur, skills_end;
	//free any existing elements first
	skills_cur = skills.begin();
	skills_end = skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		delete skills_cur->second;
	}
	
}

void BillOfMaterials::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sBillOfMaterials", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%sheader_rawMaterials='%s'", pfx, header_rawMaterials.c_str());
	_log(l_type, "%sheader_extras='%s'", pfx, header_extras.c_str());
	_log(l_type, "%sheader_wasteMaterials='%s'", pfx, header_wasteMaterials.c_str());
	_log(l_type, "%sheader_skills='%s'", pfx, header_skills.c_str());
	_log(l_type, "%srawMaterials:", pfx);
	std::string rawMaterials_n(pfx);
	rawMaterials_n += "    ";
	rawMaterials.Dump(l_type, rawMaterials_n.c_str());
	_log(l_type, "%sextras:", pfx);
	std::string extras_n(pfx);
	extras_n += "    ";
	extras.Dump(l_type, extras_n.c_str());
	_log(l_type, "%swasteMaterials:", pfx);
	std::string wasteMaterials_n(pfx);
	wasteMaterials_n += "    ";
	wasteMaterials.Dump(l_type, wasteMaterials_n.c_str());
	_log(l_type, "%sskills: Dictionaty with %d enetires", pfx, skills.size());
	std::map<uint32, PyRep *>::const_iterator skills_cur, skills_end;
	skills_cur = skills.begin();
	skills_end = skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, skills_cur->first);
		std::string n(pfx);
		n += "        ";
		skills_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepObject *BillOfMaterials::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(4, NULL);
	list2->items[0] = new PyRepString(header_rawMaterials);
	list2->items[1] = new PyRepString(header_extras);
	list2->items[2] = new PyRepString(header_wasteMaterials);
	list2->items[3] = new PyRepString(header_skills);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
		list3->items[0] = rawMaterials.Encode();
		list3->items[1] = extras.Encode();
		list3->items[2] = wasteMaterials.Encode();
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator skills_cur, skills_end;
	skills_cur = skills.begin();
	skills_end = skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		dict4->items[
			new PyRepInteger(skills_cur->first)
		] = skills_cur->second->Clone();
	}
	list3->items[3] = dict4;
	
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *BillOfMaterials::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(4, NULL);
	list2->items[0] = new PyRepString(header_rawMaterials);
	list2->items[1] = new PyRepString(header_extras);
	list2->items[2] = new PyRepString(header_wasteMaterials);
	list2->items[3] = new PyRepString(header_skills);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
		list3->items[0] = rawMaterials.FastEncode();
		list3->items[1] = extras.FastEncode();
		list3->items[2] = wasteMaterials.FastEncode();
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator skills_cur, skills_end;
	skills_cur = skills.begin();
	skills_end = skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		dict4->items[
			new PyRepInteger(skills_cur->first)
		] = skills_cur->second;
	}
	skills.clear();
	list3->items[3] = dict4;
	
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool BillOfMaterials::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool BillOfMaterials::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_line = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: list2 is the wrong size: expected 4, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: header_rawMaterials is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	header_rawMaterials = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: header_extras is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	header_extras = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: header_wasteMaterials is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	header_wasteMaterials = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: header_skills is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	header_skills = string_6->value;
		} else
		if(key_string__->value == "line") {
			dict1_line = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: list7 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list7 = (PyRepList *) dict1_cur->second;
	if(list7->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: list7 is the wrong size: expected 4, but got %d", list7->items.size());
		delete packet;
		return(false);
	}

	PyRep *rep_8 = list7->items[0];
	list7->items[0] = NULL;
	if(!rawMaterials.Decode(&rep_8)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: unable to decode element rawMaterials");
		delete packet;
		return(false);
	}
	
	PyRep *rep_9 = list7->items[1];
	list7->items[1] = NULL;
	if(!extras.Decode(&rep_9)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: unable to decode element extras");
		delete packet;
		return(false);
	}
	
	PyRep *rep_10 = list7->items[2];
	list7->items[2] = NULL;
	if(!wasteMaterials.Decode(&rep_10)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: unable to decode element wasteMaterials");
		delete packet;
		return(false);
	}
	
	if(!list7->items[3]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: skills is not a dict: %s", list7->items[3]->TypeString());
		delete packet;
		return(false);
	}
	skills.clear();
	PyRepDict *dict_11 = (PyRepDict *) list7->items[3];
	PyRepDict::iterator skills_cur, skills_end;
	skills_cur = dict_11->items.begin();
	skills_end = dict_11->items.end();
	int skills_index;
	for(skills_index = 0; skills_cur != skills_end; skills_cur++, skills_index++) {
		if(!skills_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: Key %d in dict skills is not an integer: %s", skills_index, skills_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) skills_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode BillOfMaterials: truncating 64 bit into into 32 bit int in key of entry %d in field skills", skills_index);
		}
		skills[k->value] = skills_cur->second->Clone();
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_line) {
		_log(NET__PACKET_ERROR, "Decode BillOfMaterials failed: Missing dict entry for 'line' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

BillOfMaterials *BillOfMaterials::Clone() const {
	BillOfMaterials *res = new BillOfMaterials;
	res->CloneFrom(this);
	return(res);
}

void BillOfMaterials::CloneFrom(const BillOfMaterials *from) {
	/* object of type util.Row */
	header_rawMaterials = from->header_rawMaterials;
	header_extras = from->header_extras;
	header_wasteMaterials = from->header_wasteMaterials;
	header_skills = from->header_skills;
	rawMaterials.CloneFrom(&from->rawMaterials);
	extras.CloneFrom(&from->extras);
	wasteMaterials.CloneFrom(&from->wasteMaterials);
	std::map<uint32, PyRep *>::const_iterator skills_cur, skills_end;
	//free any existing elements first
	skills_cur = skills.begin();
	skills_end = skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		delete skills_cur->second;
	}
	skills.clear();
	//now we can copy in the new ones...
	skills_cur = from->skills.begin();
	skills_end = from->skills.end();
	for(; skills_cur != skills_end; skills_cur++) {
		skills[skills_cur->first] = skills_cur->second->Clone();
	}
	
	
}


Rsp_InstallJob::Rsp_InstallJob() {
	/* object of type util.Row */
	header_bom = "bom";
	header_materialMultiplier = "materialMultiplier";
	header_charMaterialMultiplier = "charMaterialMultiplier";
	header_timeMultiplier = "timeMultiplier";
	header_charTimeMultiplier = "charTimeMultiplier";
	header_cost = "cost";
	header_installCost = "installCost";
	header_usageCost = "usageCost";
	header_productionTime = "productionTime";
	header_maxJobStartTime = "maxJobStartTime";
	materialMultiplier = 0.0;
	charMaterialMultiplier = 0.0;
	timeMultiplier = 0.0;
	charTimeMultiplier = 0.0;
	cost = 0.0;
	installCost = 0.0;
	usageCost = 0.0;
	productionTime = 0;
	maxJobStartTime = 0;
	/*  optional  */
	installedItemID = 0;
}

Rsp_InstallJob::~Rsp_InstallJob() {
	/*  optional  */
}

void Rsp_InstallJob::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_InstallJob", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%sheader_bom='%s'", pfx, header_bom.c_str());
	_log(l_type, "%sheader_materialMultiplier='%s'", pfx, header_materialMultiplier.c_str());
	_log(l_type, "%sheader_charMaterialMultiplier='%s'", pfx, header_charMaterialMultiplier.c_str());
	_log(l_type, "%sheader_timeMultiplier='%s'", pfx, header_timeMultiplier.c_str());
	_log(l_type, "%sheader_charTimeMultiplier='%s'", pfx, header_charTimeMultiplier.c_str());
	_log(l_type, "%sheader_cost='%s'", pfx, header_cost.c_str());
	_log(l_type, "%sheader_installCost='%s'", pfx, header_installCost.c_str());
	_log(l_type, "%sheader_usageCost='%s'", pfx, header_usageCost.c_str());
	_log(l_type, "%sheader_productionTime='%s'", pfx, header_productionTime.c_str());
	_log(l_type, "%sheader_maxJobStartTime='%s'", pfx, header_maxJobStartTime.c_str());
	_log(l_type, "%sbom:", pfx);
	std::string bom_n(pfx);
	bom_n += "    ";
	bom.Dump(l_type, bom_n.c_str());
	_log(l_type, "%smaterialMultiplier=%.13f", pfx, materialMultiplier);
	_log(l_type, "%scharMaterialMultiplier=%.13f", pfx, charMaterialMultiplier);
	_log(l_type, "%stimeMultiplier=%.13f", pfx, timeMultiplier);
	_log(l_type, "%scharTimeMultiplier=%.13f", pfx, charTimeMultiplier);
	_log(l_type, "%scost=%.13f", pfx, cost);
	_log(l_type, "%sinstallCost=%.13f", pfx, installCost);
	_log(l_type, "%susageCost=%.13f", pfx, usageCost);
	_log(l_type, "%sproductionTime=%lu", pfx, productionTime);
	_log(l_type, "%smaxJobStartTime=" I64u, pfx, maxJobStartTime);
	/*  optional  */
	_log(l_type, "%sinstalledItemID=%lu", pfx, installedItemID);
}

PyRepTuple *Rsp_InstallJob::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(10, NULL);
	list3->items[0] = new PyRepString(header_bom);
	list3->items[1] = new PyRepString(header_materialMultiplier);
	list3->items[2] = new PyRepString(header_charMaterialMultiplier);
	list3->items[3] = new PyRepString(header_timeMultiplier);
	list3->items[4] = new PyRepString(header_charTimeMultiplier);
	list3->items[5] = new PyRepString(header_cost);
	list3->items[6] = new PyRepString(header_installCost);
	list3->items[7] = new PyRepString(header_usageCost);
	list3->items[8] = new PyRepString(header_productionTime);
	list3->items[9] = new PyRepString(header_maxJobStartTime);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(10, NULL);
		list4->items[0] = bom.Encode();
	list4->items[1] = new PyRepReal(materialMultiplier);
	list4->items[2] = new PyRepReal(charMaterialMultiplier);
	list4->items[3] = new PyRepReal(timeMultiplier);
	list4->items[4] = new PyRepReal(charTimeMultiplier);
	list4->items[5] = new PyRepReal(cost);
	list4->items[6] = new PyRepReal(installCost);
	list4->items[7] = new PyRepReal(usageCost);
	list4->items[8] = new PyRepInteger(productionTime);
	list4->items[9] = new PyRepInteger(maxJobStartTime);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  optional  */
	tuple0->items[1] = new PyRepInteger(installedItemID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Rsp_InstallJob::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(10, NULL);
	list3->items[0] = new PyRepString(header_bom);
	list3->items[1] = new PyRepString(header_materialMultiplier);
	list3->items[2] = new PyRepString(header_charMaterialMultiplier);
	list3->items[3] = new PyRepString(header_timeMultiplier);
	list3->items[4] = new PyRepString(header_charTimeMultiplier);
	list3->items[5] = new PyRepString(header_cost);
	list3->items[6] = new PyRepString(header_installCost);
	list3->items[7] = new PyRepString(header_usageCost);
	list3->items[8] = new PyRepString(header_productionTime);
	list3->items[9] = new PyRepString(header_maxJobStartTime);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(10, NULL);
		list4->items[0] = bom.FastEncode();
	list4->items[1] = new PyRepReal(materialMultiplier);
	list4->items[2] = new PyRepReal(charMaterialMultiplier);
	list4->items[3] = new PyRepReal(timeMultiplier);
	list4->items[4] = new PyRepReal(charTimeMultiplier);
	list4->items[5] = new PyRepReal(cost);
	list4->items[6] = new PyRepReal(installCost);
	list4->items[7] = new PyRepReal(usageCost);
	list4->items[8] = new PyRepInteger(productionTime);
	list4->items[9] = new PyRepInteger(maxJobStartTime);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  optional  */
	tuple0->items[1] = new PyRepInteger(installedItemID);
	res = tuple0;
	

	return(res);
}

bool Rsp_InstallJob::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_InstallJob::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: obj_1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_1 = (PyRepObject *) tuple0->items[0];
	
	if(obj_1->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: obj_1 is the wrong object type. Expected 'util.Row', got '%s'", obj_1->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_1->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: dict2 is the wrong type: %s", obj_1->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_header = false;
	bool dict2_line = false;
	PyRepDict *dict2 = (PyRepDict *) obj_1->arguments;
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict2_header = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: list3 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list3 = (PyRepList *) dict2_cur->second;
	if(list3->items.size() != 10) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: list3 is the wrong size: expected 10, but got %d", list3->items.size());
		delete packet;
		return(false);
	}

	if(!list3->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_bom is not a string: %s", list3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list3->items[0];
	header_bom = string_4->value;
	if(!list3->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_materialMultiplier is not a string: %s", list3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list3->items[1];
	header_materialMultiplier = string_5->value;
	if(!list3->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_charMaterialMultiplier is not a string: %s", list3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list3->items[2];
	header_charMaterialMultiplier = string_6->value;
	if(!list3->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_timeMultiplier is not a string: %s", list3->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list3->items[3];
	header_timeMultiplier = string_7->value;
	if(!list3->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_charTimeMultiplier is not a string: %s", list3->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list3->items[4];
	header_charTimeMultiplier = string_8->value;
	if(!list3->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_cost is not a string: %s", list3->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list3->items[5];
	header_cost = string_9->value;
	if(!list3->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_installCost is not a string: %s", list3->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list3->items[6];
	header_installCost = string_10->value;
	if(!list3->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_usageCost is not a string: %s", list3->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list3->items[7];
	header_usageCost = string_11->value;
	if(!list3->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_productionTime is not a string: %s", list3->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) list3->items[8];
	header_productionTime = string_12->value;
	if(!list3->items[9]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: header_maxJobStartTime is not a string: %s", list3->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_13 = (PyRepString *) list3->items[9];
	header_maxJobStartTime = string_13->value;
		} else
		if(key_string__->value == "line") {
			dict2_line = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: list14 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list14 = (PyRepList *) dict2_cur->second;
	if(list14->items.size() != 10) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: list14 is the wrong size: expected 10, but got %d", list14->items.size());
		delete packet;
		return(false);
	}

	PyRep *rep_15 = list14->items[0];
	list14->items[0] = NULL;
	if(!bom.Decode(&rep_15)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: unable to decode element bom");
		delete packet;
		return(false);
	}
	
	if(!list14->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: materialMultiplier is not a real: %s", list14->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_16 = (PyRepReal *) list14->items[1];
	materialMultiplier = real_16->value;
	if(!list14->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: charMaterialMultiplier is not a real: %s", list14->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_17 = (PyRepReal *) list14->items[2];
	charMaterialMultiplier = real_17->value;
	if(!list14->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: timeMultiplier is not a real: %s", list14->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_18 = (PyRepReal *) list14->items[3];
	timeMultiplier = real_18->value;
	if(!list14->items[4]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: charTimeMultiplier is not a real: %s", list14->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_19 = (PyRepReal *) list14->items[4];
	charTimeMultiplier = real_19->value;
	if(!list14->items[5]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: cost is not a real: %s", list14->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_20 = (PyRepReal *) list14->items[5];
	cost = real_20->value;
	if(!list14->items[6]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: installCost is not a real: %s", list14->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_21 = (PyRepReal *) list14->items[6];
	installCost = real_21->value;
	if(!list14->items[7]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: usageCost is not a real: %s", list14->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_22 = (PyRepReal *) list14->items[7];
	usageCost = real_22->value;
	if(!list14->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: productionTime is not an int: %s", list14->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_23 = (PyRepInteger *) list14->items[8];
	if(int_23->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_InstallJob: truncating 64 bit into into 32 bit int for field productionTime");
	}
	productionTime = int_23->value;
	if(!list14->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: maxJobStartTime is not an int: %s", list14->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_24 = (PyRepInteger *) list14->items[9];
	maxJobStartTime = int64_24->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: Missing dict entry for 'header' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_line) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: Missing dict entry for 'line' in dict2");
		delete packet;
		return(false);
	}
	
	/*  optional  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_InstallJob failed: installedItemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_25 = (PyRepInteger *) tuple0->items[1];
	if(int_25->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_InstallJob: truncating 64 bit into into 32 bit int for field installedItemID");
	}
	installedItemID = int_25->value;

	delete packet;
	return(true);
}

Rsp_InstallJob *Rsp_InstallJob::Clone() const {
	Rsp_InstallJob *res = new Rsp_InstallJob;
	res->CloneFrom(this);
	return(res);
}

void Rsp_InstallJob::CloneFrom(const Rsp_InstallJob *from) {
	/* object of type util.Row */
	header_bom = from->header_bom;
	header_materialMultiplier = from->header_materialMultiplier;
	header_charMaterialMultiplier = from->header_charMaterialMultiplier;
	header_timeMultiplier = from->header_timeMultiplier;
	header_charTimeMultiplier = from->header_charTimeMultiplier;
	header_cost = from->header_cost;
	header_installCost = from->header_installCost;
	header_usageCost = from->header_usageCost;
	header_productionTime = from->header_productionTime;
	header_maxJobStartTime = from->header_maxJobStartTime;
	bom.CloneFrom(&from->bom);
	materialMultiplier = from->materialMultiplier;
	charMaterialMultiplier = from->charMaterialMultiplier;
	timeMultiplier = from->timeMultiplier;
	charTimeMultiplier = from->charTimeMultiplier;
	cost = from->cost;
	installCost = from->installCost;
	usageCost = from->usageCost;
	productionTime = from->productionTime;
	maxJobStartTime = from->maxJobStartTime;
	/*  optional  */
	installedItemID = from->installedItemID;
	
}


Call_CompleteJob::Call_CompleteJob() {
	/*  installationLocationData  */
	/*  invLocation  */
	invLocationID = 0;
	invLocationGroupID = 0;
	containerID = 0;
	jobID = 0;
	cancel = false;
}

Call_CompleteJob::~Call_CompleteJob() {
	/*  installationLocationData  */
	/*  invLocation  */
}

void Call_CompleteJob::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_CompleteJob", pfx);
	/*  installationLocationData  */
	/*  invLocation  */
	_log(l_type, "%sinvLocationID=%lu", pfx, invLocationID);
	_log(l_type, "%sinvLocationGroupID=%lu", pfx, invLocationGroupID);
	_log(l_type, "%scontainerID=%lu", pfx, containerID);
	_log(l_type, "%sjobID=%lu", pfx, jobID);
	_log(l_type, "%scancel=%s", pfx, cancel?"true":"false");
}

PyRepTuple *Call_CompleteJob::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	/*  installationLocationData  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(2, NULL);
	/*  invLocation  */
	list2->items[0] = new PyRepInteger(invLocationID);
	list2->items[1] = new PyRepInteger(invLocationGroupID);
	list1->items[0] = list2;
	
	PyRepList *list3 = new PyRepList();
	list3->items.resize(0, NULL);
	list1->items[1] = list3;
	
	PyRepList *list4 = new PyRepList();
	list4->items.resize(1, NULL);
	list4->items[0] = new PyRepInteger(containerID);
	list1->items[2] = list4;
	
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepInteger(jobID);
	tuple0->items[2] = new PyRepBoolean(cancel);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_CompleteJob::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	/*  installationLocationData  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(2, NULL);
	/*  invLocation  */
	list2->items[0] = new PyRepInteger(invLocationID);
	list2->items[1] = new PyRepInteger(invLocationGroupID);
	list1->items[0] = list2;
	
	PyRepList *list3 = new PyRepList();
	list3->items.resize(0, NULL);
	list1->items[1] = list3;
	
	PyRepList *list4 = new PyRepList();
	list4->items.resize(1, NULL);
	list4->items[0] = new PyRepInteger(containerID);
	list1->items[2] = list4;
	
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepInteger(jobID);
	tuple0->items[2] = new PyRepBoolean(cancel);
	res = tuple0;
	

	return(res);
}

bool Call_CompleteJob::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_CompleteJob::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list1 is the wrong size: expected 3, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  installationLocationData  */
	if(!list1->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list2 is not a list: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) list1->items[0];
	if(list2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list2 is the wrong size: expected 2, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	/*  invLocation  */
	if(!list2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: invLocationID is not an int: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_CompleteJob: truncating 64 bit into into 32 bit int for field invLocationID");
	}
	invLocationID = int_3->value;
	if(!list2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: invLocationGroupID is not an int: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_CompleteJob: truncating 64 bit into into 32 bit int for field invLocationGroupID");
	}
	invLocationGroupID = int_4->value;
	if(!list1->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list5 is not a list: %s", list1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) list1->items[1];
	if(list5->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list5 is the wrong size: expected 0, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	if(!list1->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list6 is not a list: %s", list1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list6 = (PyRepList *) list1->items[2];
	if(list6->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: list6 is the wrong size: expected 1, but got %d", list6->items.size());
		delete packet;
		return(false);
	}

	if(!list6->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: containerID is not an int: %s", list6->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) list6->items[0];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_CompleteJob: truncating 64 bit into into 32 bit int for field containerID");
	}
	containerID = int_7->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: jobID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple0->items[1];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_CompleteJob: truncating 64 bit into into 32 bit int for field jobID");
	}
	jobID = int_8->value;
	if(!tuple0->items[2]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Call_CompleteJob failed: cancel is not a boolean: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_9 = (PyRepBoolean *) tuple0->items[2];
	cancel = bool_9->value;

	delete packet;
	return(true);
}

Call_CompleteJob *Call_CompleteJob::Clone() const {
	Call_CompleteJob *res = new Call_CompleteJob;
	res->CloneFrom(this);
	return(res);
}

void Call_CompleteJob::CloneFrom(const Call_CompleteJob *from) {
	/*  installationLocationData  */
	/*  invLocation  */
	invLocationID = from->invLocationID;
	invLocationGroupID = from->invLocationGroupID;
	containerID = from->containerID;
	jobID = from->jobID;
	cancel = from->cancel;
	
}



