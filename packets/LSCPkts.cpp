/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "LSCPkts.h"
#include "../common/PyRep.h"




ChannelInfo::ChannelInfo() {
	/* object of type util.Rowset */
	uu_1 = "channelID";
	uu_2 = "ownerID";
	uu_3 = "displayName";
	uu_4 = "motd";
	uu_5 = "comparisonKey";
	uu_6 = "memberless";
	uu_7 = "password";
	uu_8 = "mailingList";
	uu_9 = "cspa";
	uu_10 = "temporary";
	uu_11 = "mode";
	uu_12 = "subscribed";
	uu_13 = "estimatedMemberCount";
	rowclass = "util.Row";
}

ChannelInfo::~ChannelInfo() {
}

void ChannelInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelInfo", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%suu_1='%s'", pfx, uu_1.c_str());
	_log(l_type, "%suu_2='%s'", pfx, uu_2.c_str());
	_log(l_type, "%suu_3='%s'", pfx, uu_3.c_str());
	_log(l_type, "%suu_4='%s'", pfx, uu_4.c_str());
	_log(l_type, "%suu_5='%s'", pfx, uu_5.c_str());
	_log(l_type, "%suu_6='%s'", pfx, uu_6.c_str());
	_log(l_type, "%suu_7='%s'", pfx, uu_7.c_str());
	_log(l_type, "%suu_8='%s'", pfx, uu_8.c_str());
	_log(l_type, "%suu_9='%s'", pfx, uu_9.c_str());
	_log(l_type, "%suu_10='%s'", pfx, uu_10.c_str());
	_log(l_type, "%suu_11='%s'", pfx, uu_11.c_str());
	_log(l_type, "%suu_12='%s'", pfx, uu_12.c_str());
	_log(l_type, "%suu_13='%s'", pfx, uu_13.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *ChannelInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(13, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	list2->items[6] = new PyRepString(uu_7);
	list2->items[7] = new PyRepString(uu_8);
	list2->items[8] = new PyRepString(uu_9);
	list2->items[9] = new PyRepString(uu_10);
	list2->items[10] = new PyRepString(uu_11);
	list2->items[11] = new PyRepString(uu_12);
	list2->items[12] = new PyRepString(uu_13);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

PyRepObject *ChannelInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(13, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	list2->items[6] = new PyRepString(uu_7);
	list2->items[7] = new PyRepString(uu_8);
	list2->items[8] = new PyRepString(uu_9);
	list2->items[9] = new PyRepString(uu_10);
	list2->items[10] = new PyRepString(uu_11);
	list2->items[11] = new PyRepString(uu_12);
	list2->items[12] = new PyRepString(uu_13);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	
	PyRepList *list3 = new PyRepList();
	list3->items = lines.items;
	lines.items.clear();
	dict1_2 = list3;
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool ChannelInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_uu_0 = false;
	bool dict1_rowclass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_uu_0 = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 13) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: list2 is the wrong size: expected 13, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_1 is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	uu_1 = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_2 is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	uu_2 = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_3 is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	uu_3 = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_4 is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	uu_4 = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_5 is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	uu_5 = string_7->value;
	if(!list2->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_6 is not a string: %s", list2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list2->items[5];
	uu_6 = string_8->value;
	if(!list2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_7 is not a string: %s", list2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list2->items[6];
	uu_7 = string_9->value;
	if(!list2->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_8 is not a string: %s", list2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list2->items[7];
	uu_8 = string_10->value;
	if(!list2->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_9 is not a string: %s", list2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list2->items[8];
	uu_9 = string_11->value;
	if(!list2->items[9]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_10 is not a string: %s", list2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) list2->items[9];
	uu_10 = string_12->value;
	if(!list2->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_11 is not a string: %s", list2->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_13 = (PyRepString *) list2->items[10];
	uu_11 = string_13->value;
	if(!list2->items[11]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_12 is not a string: %s", list2->items[11]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_14 = (PyRepString *) list2->items[11];
	uu_12 = string_14->value;
	if(!list2->items[12]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: uu_13 is not a string: %s", list2->items[12]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_15 = (PyRepString *) list2->items[12];
	uu_13 = string_15->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_16 = (PyRepString *) dict1_cur->second;
	rowclass = string_16->value;
	if(string_16->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_16->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_uu_0) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: Missing dict entry for 'uu_0' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfo failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

ChannelInfo *ChannelInfo::Clone() const {
	ChannelInfo *res = new ChannelInfo;
	res->CloneFrom(this);
	return(res);
}

void ChannelInfo::CloneFrom(const ChannelInfo *from) {
	/* object of type util.Rowset */
	uu_1 = from->uu_1;
	uu_2 = from->uu_2;
	uu_3 = from->uu_3;
	uu_4 = from->uu_4;
	uu_5 = from->uu_5;
	uu_6 = from->uu_6;
	uu_7 = from->uu_7;
	uu_8 = from->uu_8;
	uu_9 = from->uu_9;
	uu_10 = from->uu_10;
	uu_11 = from->uu_11;
	uu_12 = from->uu_12;
	uu_13 = from->uu_13;
	rowclass = from->rowclass;
	lines.CloneFrom(&from->lines);
	
}


ChannelInfoLine::ChannelInfoLine() {
	channelID = 0;
	ownerID = 0;
	displayName = "";
	motd = "";
	comparisonKey = "";
	memberless = false;
	password = "";
	mailingList = 0;
	cspa = 0;
	temporary = 0;
	mode = 0;
	subscribed = false;
	estimatedMemberCount = 0;
}

ChannelInfoLine::~ChannelInfoLine() {
}

void ChannelInfoLine::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelInfoLine", pfx);
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%sdisplayName='%s'", pfx, displayName.c_str());
	_log(l_type, "%smotd='%s'", pfx, motd.c_str());
	_log(l_type, "%scomparisonKey='%s'", pfx, comparisonKey.c_str());
	_log(l_type, "%smemberless=%s", pfx, memberless?"true":"false");
	_log(l_type, "%spassword='%s'", pfx, password.c_str());
	_log(l_type, "%smailingList=%lu", pfx, mailingList);
	_log(l_type, "%scspa=%lu", pfx, cspa);
	_log(l_type, "%stemporary=%lu", pfx, temporary);
	_log(l_type, "%smode=%lu", pfx, mode);
	_log(l_type, "%ssubscribed=%s", pfx, subscribed?"true":"false");
	_log(l_type, "%sestimatedMemberCount=%lu", pfx, estimatedMemberCount);
}

PyRepList *ChannelInfoLine::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(13, NULL);
	list0->items[0] = new PyRepInteger(channelID);
	list0->items[1] = new PyRepInteger(ownerID);
	list0->items[2] = new PyRepString(displayName);
	list0->items[3] = new PyRepString(motd);
	list0->items[4] = new PyRepString(comparisonKey);
	list0->items[5] = new PyRepBoolean(memberless);
	list0->items[6] = new PyRepString(password);
	list0->items[7] = new PyRepInteger(mailingList);
	list0->items[8] = new PyRepInteger(cspa);
	list0->items[9] = new PyRepInteger(temporary);
	list0->items[10] = new PyRepInteger(mode);
	list0->items[11] = new PyRepBoolean(subscribed);
	list0->items[12] = new PyRepInteger(estimatedMemberCount);
	res = list0;
	

	return(res);
}

PyRepList *ChannelInfoLine::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(13, NULL);
	list0->items[0] = new PyRepInteger(channelID);
	list0->items[1] = new PyRepInteger(ownerID);
	list0->items[2] = new PyRepString(displayName);
	list0->items[3] = new PyRepString(motd);
	list0->items[4] = new PyRepString(comparisonKey);
	list0->items[5] = new PyRepBoolean(memberless);
	list0->items[6] = new PyRepString(password);
	list0->items[7] = new PyRepInteger(mailingList);
	list0->items[8] = new PyRepInteger(cspa);
	list0->items[9] = new PyRepInteger(temporary);
	list0->items[10] = new PyRepInteger(mode);
	list0->items[11] = new PyRepBoolean(subscribed);
	list0->items[12] = new PyRepInteger(estimatedMemberCount);
	res = list0;
	

	return(res);
}

bool ChannelInfoLine::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelInfoLine::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 13) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: list0 is the wrong size: expected 13, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: channelID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: ownerID is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: displayName is not a string: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list0->items[2];
	displayName = string_3->value;
	if(!list0->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: motd is not a string: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list0->items[3];
	motd = string_4->value;
	if(!list0->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: comparisonKey is not a string: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list0->items[4];
	comparisonKey = string_5->value;
	if(!list0->items[5]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: memberless is not a boolean: %s", list0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_6 = (PyRepBoolean *) list0->items[5];
	memberless = bool_6->value;
	if(!list0->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: password is not a string: %s", list0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list0->items[6];
	password = string_7->value;
	if(!list0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: mailingList is not an int: %s", list0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list0->items[7];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field mailingList");
	}
	mailingList = int_8->value;
	if(!list0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: cspa is not an int: %s", list0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list0->items[8];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field cspa");
	}
	cspa = int_9->value;
	if(!list0->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: temporary is not an int: %s", list0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) list0->items[9];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field temporary");
	}
	temporary = int_10->value;
	if(!list0->items[10]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: mode is not an int: %s", list0->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) list0->items[10];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field mode");
	}
	mode = int_11->value;
	if(!list0->items[11]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: subscribed is not a boolean: %s", list0->items[11]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_12 = (PyRepBoolean *) list0->items[11];
	subscribed = bool_12->value;
	if(!list0->items[12]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelInfoLine failed: estimatedMemberCount is not an int: %s", list0->items[12]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) list0->items[12];
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelInfoLine: truncating 64 bit into into 32 bit int for field estimatedMemberCount");
	}
	estimatedMemberCount = int_13->value;

	delete packet;
	return(true);
}

ChannelInfoLine *ChannelInfoLine::Clone() const {
	ChannelInfoLine *res = new ChannelInfoLine;
	res->CloneFrom(this);
	return(res);
}

void ChannelInfoLine::CloneFrom(const ChannelInfoLine *from) {
	channelID = from->channelID;
	ownerID = from->ownerID;
	displayName = from->displayName;
	motd = from->motd;
	comparisonKey = from->comparisonKey;
	memberless = from->memberless;
	password = from->password;
	mailingList = from->mailingList;
	cspa = from->cspa;
	temporary = from->temporary;
	mode = from->mode;
	subscribed = from->subscribed;
	estimatedMemberCount = from->estimatedMemberCount;
	
}


ChannelJoinChannelInfo::ChannelJoinChannelInfo() {
	/* object of type util.Row */
	uu_1 = "channelID";
	uu_2 = "ownerID";
	uu_3 = "displayName";
	uu_4 = "motd";
	uu_5 = "comparisonKey";
	uu_6 = "memberless";
	uu_7 = "password";
	uu_8 = "mailingList";
	uu_9 = "cspa";
	uu_10 = "temporary";
	uu_12 = "subscribed";
	channelID = 0;
	ownerID = 0;
	displayName = "";
	motd = "";
	comparisonKey = "";
	memberless = false;
	password = NULL;
	mailingList = 0;
	cspa = 0;
	temporary = 0;
	subscribed = 0;
}

ChannelJoinChannelInfo::~ChannelJoinChannelInfo() {
	delete password;
}

void ChannelJoinChannelInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinChannelInfo", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%suu_1='%s'", pfx, uu_1.c_str());
	_log(l_type, "%suu_2='%s'", pfx, uu_2.c_str());
	_log(l_type, "%suu_3='%s'", pfx, uu_3.c_str());
	_log(l_type, "%suu_4='%s'", pfx, uu_4.c_str());
	_log(l_type, "%suu_5='%s'", pfx, uu_5.c_str());
	_log(l_type, "%suu_6='%s'", pfx, uu_6.c_str());
	_log(l_type, "%suu_7='%s'", pfx, uu_7.c_str());
	_log(l_type, "%suu_8='%s'", pfx, uu_8.c_str());
	_log(l_type, "%suu_9='%s'", pfx, uu_9.c_str());
	_log(l_type, "%suu_10='%s'", pfx, uu_10.c_str());
	_log(l_type, "%suu_12='%s'", pfx, uu_12.c_str());
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%sdisplayName='%s'", pfx, displayName.c_str());
	_log(l_type, "%smotd='%s'", pfx, motd.c_str());
	_log(l_type, "%scomparisonKey='%s'", pfx, comparisonKey.c_str());
	_log(l_type, "%smemberless=%s", pfx, memberless?"true":"false");
	_log(l_type, "%spassword:", pfx);
	std::string password_n(pfx);
	password_n += "    ";
	if(password == NULL) {
		_log(l_type, "%sERROR: NULL REP!", password_n.c_str());
	} else {
		password->Dump(l_type, password_n.c_str());
	}
	_log(l_type, "%smailingList=%lu", pfx, mailingList);
	_log(l_type, "%scspa=%lu", pfx, cspa);
	_log(l_type, "%stemporary=%lu", pfx, temporary);
	_log(l_type, "%ssubscribed=%lu", pfx, subscribed);
}

PyRepObject *ChannelJoinChannelInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	list2->items[6] = new PyRepString(uu_7);
	list2->items[7] = new PyRepString(uu_8);
	list2->items[8] = new PyRepString(uu_9);
	list2->items[9] = new PyRepString(uu_10);
	list2->items[10] = new PyRepString(uu_12);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(channelID);
	list3->items[1] = new PyRepInteger(ownerID);
	list3->items[2] = new PyRepString(displayName);
	list3->items[3] = new PyRepString(motd);
	list3->items[4] = new PyRepString(comparisonKey);
	list3->items[5] = new PyRepBoolean(memberless);
	if(password == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinChannelInfo: password is NULL! hacking in a PyRepNone");
		password = new PyRepNone();
	}
	list3->items[6] = password->Clone();
	list3->items[7] = new PyRepInteger(mailingList);
	list3->items[8] = new PyRepInteger(cspa);
	list3->items[9] = new PyRepInteger(temporary);
	list3->items[10] = new PyRepInteger(subscribed);
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *ChannelJoinChannelInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	list2->items[6] = new PyRepString(uu_7);
	list2->items[7] = new PyRepString(uu_8);
	list2->items[8] = new PyRepString(uu_9);
	list2->items[9] = new PyRepString(uu_10);
	list2->items[10] = new PyRepString(uu_12);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(channelID);
	list3->items[1] = new PyRepInteger(ownerID);
	list3->items[2] = new PyRepString(displayName);
	list3->items[3] = new PyRepString(motd);
	list3->items[4] = new PyRepString(comparisonKey);
	list3->items[5] = new PyRepBoolean(memberless);
	if(password == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinChannelInfo: password is NULL! hacking in a PyRepNone");
		password = new PyRepNone();
	}
	list3->items[6] = password;
	password = NULL;
	list3->items[7] = new PyRepInteger(mailingList);
	list3->items[8] = new PyRepInteger(cspa);
	list3->items[9] = new PyRepInteger(temporary);
	list3->items[10] = new PyRepInteger(subscribed);
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool ChannelJoinChannelInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinChannelInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_uu_0 = false;
	bool dict1_uu_13 = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_uu_0 = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: list2 is the wrong size: expected 11, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_1 is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	uu_1 = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_2 is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	uu_2 = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_3 is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	uu_3 = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_4 is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	uu_4 = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_5 is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	uu_5 = string_7->value;
	if(!list2->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_6 is not a string: %s", list2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list2->items[5];
	uu_6 = string_8->value;
	if(!list2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_7 is not a string: %s", list2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list2->items[6];
	uu_7 = string_9->value;
	if(!list2->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_8 is not a string: %s", list2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list2->items[7];
	uu_8 = string_10->value;
	if(!list2->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_9 is not a string: %s", list2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list2->items[8];
	uu_9 = string_11->value;
	if(!list2->items[9]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_10 is not a string: %s", list2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) list2->items[9];
	uu_10 = string_12->value;
	if(!list2->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: uu_12 is not a string: %s", list2->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_13 = (PyRepString *) list2->items[10];
	uu_12 = string_13->value;
		} else
		if(key_string__->value == "line") {
			dict1_uu_13 = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: list14 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list14 = (PyRepList *) dict1_cur->second;
	if(list14->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: list14 is the wrong size: expected 11, but got %d", list14->items.size());
		delete packet;
		return(false);
	}

	if(!list14->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: channelID is not an int: %s", list14->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_15 = (PyRepInteger *) list14->items[0];
	if(int_15->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_15->value;
	if(!list14->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: ownerID is not an int: %s", list14->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_16 = (PyRepInteger *) list14->items[1];
	if(int_16->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_16->value;
	if(!list14->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: displayName is not a string: %s", list14->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_17 = (PyRepString *) list14->items[2];
	displayName = string_17->value;
	if(!list14->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: motd is not a string: %s", list14->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_18 = (PyRepString *) list14->items[3];
	motd = string_18->value;
	if(!list14->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: comparisonKey is not a string: %s", list14->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_19 = (PyRepString *) list14->items[4];
	comparisonKey = string_19->value;
	if(!list14->items[5]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: memberless is not a boolean: %s", list14->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_20 = (PyRepBoolean *) list14->items[5];
	memberless = bool_20->value;
	delete password;
	password = list14->items[6];
	list14->items[6] = NULL;
	
	if(!list14->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: mailingList is not an int: %s", list14->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_21 = (PyRepInteger *) list14->items[7];
	if(int_21->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field mailingList");
	}
	mailingList = int_21->value;
	if(!list14->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: cspa is not an int: %s", list14->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_22 = (PyRepInteger *) list14->items[8];
	if(int_22->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field cspa");
	}
	cspa = int_22->value;
	if(!list14->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: temporary is not an int: %s", list14->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_23 = (PyRepInteger *) list14->items[9];
	if(int_23->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field temporary");
	}
	temporary = int_23->value;
	if(!list14->items[10]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: subscribed is not an int: %s", list14->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_24 = (PyRepInteger *) list14->items[10];
	if(int_24->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelInfo: truncating 64 bit into into 32 bit int for field subscribed");
	}
	subscribed = int_24->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_uu_0) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: Missing dict entry for 'uu_0' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_uu_13) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelInfo failed: Missing dict entry for 'uu_13' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

ChannelJoinChannelInfo *ChannelJoinChannelInfo::Clone() const {
	ChannelJoinChannelInfo *res = new ChannelJoinChannelInfo;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinChannelInfo::CloneFrom(const ChannelJoinChannelInfo *from) {
	/* object of type util.Row */
	uu_1 = from->uu_1;
	uu_2 = from->uu_2;
	uu_3 = from->uu_3;
	uu_4 = from->uu_4;
	uu_5 = from->uu_5;
	uu_6 = from->uu_6;
	uu_7 = from->uu_7;
	uu_8 = from->uu_8;
	uu_9 = from->uu_9;
	uu_10 = from->uu_10;
	uu_12 = from->uu_12;
	channelID = from->channelID;
	ownerID = from->ownerID;
	displayName = from->displayName;
	motd = from->motd;
	comparisonKey = from->comparisonKey;
	memberless = from->memberless;
	delete password;
	if(from->password == NULL) {
		password = NULL;
	} else {
		password = from->password->Clone();
	}
	mailingList = from->mailingList;
	cspa = from->cspa;
	temporary = from->temporary;
	subscribed = from->subscribed;
	
}


ChannelJoinChannelMods::ChannelJoinChannelMods() {
	/* object of type util.Rowset */
	uu_1 = "accessor";
	uu_2 = "mode";
	uu_3 = "untilWhen";
	uu_4 = "originalMode";
	uu_5 = "admin";
	uu_6 = "reason";
	rowclass = "util.Row";
}

ChannelJoinChannelMods::~ChannelJoinChannelMods() {
}

void ChannelJoinChannelMods::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinChannelMods", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%suu_1='%s'", pfx, uu_1.c_str());
	_log(l_type, "%suu_2='%s'", pfx, uu_2.c_str());
	_log(l_type, "%suu_3='%s'", pfx, uu_3.c_str());
	_log(l_type, "%suu_4='%s'", pfx, uu_4.c_str());
	_log(l_type, "%suu_5='%s'", pfx, uu_5.c_str());
	_log(l_type, "%suu_6='%s'", pfx, uu_6.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *ChannelJoinChannelMods::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(6, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

PyRepObject *ChannelJoinChannelMods::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(6, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	list2->items[5] = new PyRepString(uu_6);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	
	PyRepList *list3 = new PyRepList();
	list3->items = lines.items;
	lines.items.clear();
	dict1_2 = list3;
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool ChannelJoinChannelMods::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinChannelMods::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_uu_0 = false;
	bool dict1_rowclass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_uu_0 = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: list2 is the wrong size: expected 6, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_1 is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	uu_1 = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_2 is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	uu_2 = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_3 is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	uu_3 = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_4 is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	uu_4 = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_5 is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	uu_5 = string_7->value;
	if(!list2->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: uu_6 is not a string: %s", list2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list2->items[5];
	uu_6 = string_8->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict1_cur->second;
	rowclass = string_9->value;
	if(string_9->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_9->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_uu_0) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: Missing dict entry for 'uu_0' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelMods failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

ChannelJoinChannelMods *ChannelJoinChannelMods::Clone() const {
	ChannelJoinChannelMods *res = new ChannelJoinChannelMods;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinChannelMods::CloneFrom(const ChannelJoinChannelMods *from) {
	/* object of type util.Rowset */
	uu_1 = from->uu_1;
	uu_2 = from->uu_2;
	uu_3 = from->uu_3;
	uu_4 = from->uu_4;
	uu_5 = from->uu_5;
	uu_6 = from->uu_6;
	rowclass = from->rowclass;
	lines.CloneFrom(&from->lines);
	
}


ChannelJoinChannelModsLine::ChannelJoinChannelModsLine() {
	accessor = 0;
	mode = 0;
	untilWhen = 0;
	originalMode = 0;
	admin = "";
	reason = "";
}

ChannelJoinChannelModsLine::~ChannelJoinChannelModsLine() {
}

void ChannelJoinChannelModsLine::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinChannelModsLine", pfx);
	_log(l_type, "%saccessor=%lu", pfx, accessor);
	_log(l_type, "%smode=%lu", pfx, mode);
	_log(l_type, "%suntilWhen=" I64u, pfx, untilWhen);
	_log(l_type, "%soriginalMode=%lu", pfx, originalMode);
	_log(l_type, "%sadmin='%s'", pfx, admin.c_str());
	_log(l_type, "%sreason='%s'", pfx, reason.c_str());
}

PyRepList *ChannelJoinChannelModsLine::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(6, NULL);
	list0->items[0] = new PyRepInteger(accessor);
	list0->items[1] = new PyRepInteger(mode);
	list0->items[2] = new PyRepInteger(untilWhen);
	list0->items[3] = new PyRepInteger(originalMode);
	list0->items[4] = new PyRepString(admin);
	list0->items[5] = new PyRepString(reason);
	res = list0;
	

	return(res);
}

PyRepList *ChannelJoinChannelModsLine::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(6, NULL);
	list0->items[0] = new PyRepInteger(accessor);
	list0->items[1] = new PyRepInteger(mode);
	list0->items[2] = new PyRepInteger(untilWhen);
	list0->items[3] = new PyRepInteger(originalMode);
	list0->items[4] = new PyRepString(admin);
	list0->items[5] = new PyRepString(reason);
	res = list0;
	

	return(res);
}

bool ChannelJoinChannelModsLine::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinChannelModsLine::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: list0 is the wrong size: expected 6, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: accessor is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelModsLine: truncating 64 bit into into 32 bit int for field accessor");
	}
	accessor = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: mode is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelModsLine: truncating 64 bit into into 32 bit int for field mode");
	}
	mode = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: untilWhen is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) list0->items[2];
	untilWhen = int64_3->value;
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: originalMode is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelModsLine: truncating 64 bit into into 32 bit int for field originalMode");
	}
	originalMode = int_4->value;
	if(!list0->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: admin is not a string: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list0->items[4];
	admin = string_5->value;
	if(!list0->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelModsLine failed: reason is not a string: %s", list0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list0->items[5];
	reason = string_6->value;

	delete packet;
	return(true);
}

ChannelJoinChannelModsLine *ChannelJoinChannelModsLine::Clone() const {
	ChannelJoinChannelModsLine *res = new ChannelJoinChannelModsLine;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinChannelModsLine::CloneFrom(const ChannelJoinChannelModsLine *from) {
	accessor = from->accessor;
	mode = from->mode;
	untilWhen = from->untilWhen;
	originalMode = from->originalMode;
	admin = from->admin;
	reason = from->reason;
	
}


ChannelJoinChannelChars::ChannelJoinChannelChars() {
	/* object of type util.Rowset */
	uu_1 = "charID";
	uu_2 = "corpID";
	uu_3 = "allianceID";
	uu_4 = "role";
	uu_5 = "extra";
	rowclass = "util.Row";
}

ChannelJoinChannelChars::~ChannelJoinChannelChars() {
}

void ChannelJoinChannelChars::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinChannelChars", pfx);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%suu_1='%s'", pfx, uu_1.c_str());
	_log(l_type, "%suu_2='%s'", pfx, uu_2.c_str());
	_log(l_type, "%suu_3='%s'", pfx, uu_3.c_str());
	_log(l_type, "%suu_4='%s'", pfx, uu_4.c_str());
	_log(l_type, "%suu_5='%s'", pfx, uu_5.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *ChannelJoinChannelChars::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = lines.Clone();
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

PyRepObject *ChannelJoinChannelChars::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(uu_1);
	list2->items[1] = new PyRepString(uu_2);
	list2->items[2] = new PyRepString(uu_3);
	list2->items[3] = new PyRepString(uu_4);
	list2->items[4] = new PyRepString(uu_5);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	
	PyRepList *list3 = new PyRepList();
	list3->items = lines.items;
	lines.items.clear();
	dict1_2 = list3;
	dict1->items[
		new PyRepString("lines")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Rowset",
			args0
		);
	

	return(res);
}

bool ChannelJoinChannelChars::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinChannelChars::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: obj_0 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_uu_0 = false;
	bool dict1_rowclass = false;
	bool dict1_lines = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_uu_0 = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: uu_1 is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	uu_1 = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: uu_2 is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	uu_2 = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: uu_3 is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	uu_3 = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: uu_4 is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	uu_4 = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: uu_5 is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	uu_5 = string_7->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) dict1_cur->second;
	rowclass = string_8->value;
	if(string_8->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_8->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict1_lines = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: lines is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict1_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_uu_0) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: Missing dict entry for 'uu_0' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_lines) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelChars failed: Missing dict entry for 'lines' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

ChannelJoinChannelChars *ChannelJoinChannelChars::Clone() const {
	ChannelJoinChannelChars *res = new ChannelJoinChannelChars;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinChannelChars::CloneFrom(const ChannelJoinChannelChars *from) {
	/* object of type util.Rowset */
	uu_1 = from->uu_1;
	uu_2 = from->uu_2;
	uu_3 = from->uu_3;
	uu_4 = from->uu_4;
	uu_5 = from->uu_5;
	rowclass = from->rowclass;
	lines.CloneFrom(&from->lines);
	
}


ChannelJoinChannelCharsLine::ChannelJoinChannelCharsLine() {
	charID = 0;
	corpID = 0;
	allianceID = 0;
	role = 0;
	extra = 0;
}

ChannelJoinChannelCharsLine::~ChannelJoinChannelCharsLine() {
}

void ChannelJoinChannelCharsLine::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinChannelCharsLine", pfx);
	_log(l_type, "%scharID=%lu", pfx, charID);
	_log(l_type, "%scorpID=%lu", pfx, corpID);
	_log(l_type, "%sallianceID=%lu", pfx, allianceID);
	_log(l_type, "%srole=%lu", pfx, role);
	_log(l_type, "%sextra=%lu", pfx, extra);
}

PyRepList *ChannelJoinChannelCharsLine::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(charID);
	list0->items[1] = new PyRepInteger(corpID);
	list0->items[2] = new PyRepInteger(allianceID);
	list0->items[3] = new PyRepInteger(role);
	list0->items[4] = new PyRepInteger(extra);
	res = list0;
	

	return(res);
}

PyRepList *ChannelJoinChannelCharsLine::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(charID);
	list0->items[1] = new PyRepInteger(corpID);
	list0->items[2] = new PyRepInteger(allianceID);
	list0->items[3] = new PyRepInteger(role);
	list0->items[4] = new PyRepInteger(extra);
	res = list0;
	

	return(res);
}

bool ChannelJoinChannelCharsLine::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinChannelCharsLine::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: list0 is the wrong size: expected 5, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: charID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelCharsLine: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: corpID is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelCharsLine: truncating 64 bit into into 32 bit int for field corpID");
	}
	corpID = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: allianceID is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelCharsLine: truncating 64 bit into into 32 bit int for field allianceID");
	}
	allianceID = int_3->value;
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: role is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelCharsLine: truncating 64 bit into into 32 bit int for field role");
	}
	role = int_4->value;
	if(!list0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinChannelCharsLine failed: extra is not an int: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) list0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinChannelCharsLine: truncating 64 bit into into 32 bit int for field extra");
	}
	extra = int_5->value;

	delete packet;
	return(true);
}

ChannelJoinChannelCharsLine *ChannelJoinChannelCharsLine::Clone() const {
	ChannelJoinChannelCharsLine *res = new ChannelJoinChannelCharsLine;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinChannelCharsLine::CloneFrom(const ChannelJoinChannelCharsLine *from) {
	charID = from->charID;
	corpID = from->corpID;
	allianceID = from->allianceID;
	role = from->role;
	extra = from->extra;
	
}


ChannelJoinReply::ChannelJoinReply() {
	ChannelID = NULL;
	ok = 1;
	ChannelInfo = NULL;
	ChannelMods = NULL;
	ChannelChars = NULL;
}

ChannelJoinReply::~ChannelJoinReply() {
	delete ChannelID;
	delete ChannelInfo;
	delete ChannelMods;
	delete ChannelChars;
}

void ChannelJoinReply::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelJoinReply", pfx);
	_log(l_type, "%sChannelID:", pfx);
	std::string ChannelID_n(pfx);
	ChannelID_n += "    ";
	if(ChannelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelID_n.c_str());
	} else {
		ChannelID->Dump(l_type, ChannelID_n.c_str());
	}
	_log(l_type, "%sok=%lu", pfx, ok);
	_log(l_type, "%sChannelInfo:", pfx);
	std::string ChannelInfo_n(pfx);
	ChannelInfo_n += "    ";
	if(ChannelInfo == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelInfo_n.c_str());
	} else {
		ChannelInfo->Dump(l_type, ChannelInfo_n.c_str());
	}
	_log(l_type, "%sChannelMods:", pfx);
	std::string ChannelMods_n(pfx);
	ChannelMods_n += "    ";
	if(ChannelMods == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelMods_n.c_str());
	} else {
		ChannelMods->Dump(l_type, ChannelMods_n.c_str());
	}
	_log(l_type, "%sChannelChars:", pfx);
	std::string ChannelChars_n(pfx);
	ChannelChars_n += "    ";
	if(ChannelChars == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelChars_n.c_str());
	} else {
		ChannelChars->Dump(l_type, ChannelChars_n.c_str());
	}
}

PyRepTuple *ChannelJoinReply::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	if(ChannelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelID is NULL! hacking in a PyRepNone");
		ChannelID = new PyRepNone();
	}
	tuple0->items[0] = ChannelID->Clone();
	tuple0->items[1] = new PyRepInteger(ok);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	if(ChannelInfo == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelInfo is NULL! hacking in a PyRepNone");
		ChannelInfo = new PyRepNone();
	}
	tuple1->items[0] = ChannelInfo->Clone();
	if(ChannelMods == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelMods is NULL! hacking in a PyRepNone");
		ChannelMods = new PyRepNone();
	}
	tuple1->items[1] = ChannelMods->Clone();
	if(ChannelChars == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelChars is NULL! hacking in a PyRepNone");
		ChannelChars = new PyRepNone();
	}
	tuple1->items[2] = ChannelChars->Clone();
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *ChannelJoinReply::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	if(ChannelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelID is NULL! hacking in a PyRepNone");
		ChannelID = new PyRepNone();
	}
	tuple0->items[0] = ChannelID;
	ChannelID = NULL;
	tuple0->items[1] = new PyRepInteger(ok);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	if(ChannelInfo == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelInfo is NULL! hacking in a PyRepNone");
		ChannelInfo = new PyRepNone();
	}
	tuple1->items[0] = ChannelInfo;
	ChannelInfo = NULL;
	if(ChannelMods == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelMods is NULL! hacking in a PyRepNone");
		ChannelMods = new PyRepNone();
	}
	tuple1->items[1] = ChannelMods;
	ChannelMods = NULL;
	if(ChannelChars == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelJoinReply: ChannelChars is NULL! hacking in a PyRepNone");
		ChannelChars = new PyRepNone();
	}
	tuple1->items[2] = ChannelChars;
	ChannelChars = NULL;
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool ChannelJoinReply::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelJoinReply::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinReply failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinReply failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	delete ChannelID;
	ChannelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinReply failed: ok is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode ChannelJoinReply: truncating 64 bit into into 32 bit int for field ok");
	}
	ok = int_1->value;
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinReply failed: tuple2 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[2];
	if(tuple2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode ChannelJoinReply failed: tuple2 is the wrong size: expected 3, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	delete ChannelInfo;
	ChannelInfo = tuple2->items[0];
	tuple2->items[0] = NULL;
	
	delete ChannelMods;
	ChannelMods = tuple2->items[1];
	tuple2->items[1] = NULL;
	
	delete ChannelChars;
	ChannelChars = tuple2->items[2];
	tuple2->items[2] = NULL;
	

	delete packet;
	return(true);
}

ChannelJoinReply *ChannelJoinReply::Clone() const {
	ChannelJoinReply *res = new ChannelJoinReply;
	res->CloneFrom(this);
	return(res);
}

void ChannelJoinReply::CloneFrom(const ChannelJoinReply *from) {
	delete ChannelID;
	if(from->ChannelID == NULL) {
		ChannelID = NULL;
	} else {
		ChannelID = from->ChannelID->Clone();
	}
	ok = from->ok;
	delete ChannelInfo;
	if(from->ChannelInfo == NULL) {
		ChannelInfo = NULL;
	} else {
		ChannelInfo = from->ChannelInfo->Clone();
	}
	delete ChannelMods;
	if(from->ChannelMods == NULL) {
		ChannelMods = NULL;
	} else {
		ChannelMods = from->ChannelMods->Clone();
	}
	delete ChannelChars;
	if(from->ChannelChars == NULL) {
		ChannelChars = NULL;
	} else {
		ChannelChars = from->ChannelChars->Clone();
	}
	
}


ChannelCreateReply::ChannelCreateReply() {
	ChannelInfo = NULL;
	ChannelMods = NULL;
	ChannelChars = NULL;
}

ChannelCreateReply::~ChannelCreateReply() {
	delete ChannelInfo;
	delete ChannelMods;
	delete ChannelChars;
}

void ChannelCreateReply::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sChannelCreateReply", pfx);
	_log(l_type, "%sChannelInfo:", pfx);
	std::string ChannelInfo_n(pfx);
	ChannelInfo_n += "    ";
	if(ChannelInfo == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelInfo_n.c_str());
	} else {
		ChannelInfo->Dump(l_type, ChannelInfo_n.c_str());
	}
	_log(l_type, "%sChannelMods:", pfx);
	std::string ChannelMods_n(pfx);
	ChannelMods_n += "    ";
	if(ChannelMods == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelMods_n.c_str());
	} else {
		ChannelMods->Dump(l_type, ChannelMods_n.c_str());
	}
	_log(l_type, "%sChannelChars:", pfx);
	std::string ChannelChars_n(pfx);
	ChannelChars_n += "    ";
	if(ChannelChars == NULL) {
		_log(l_type, "%sERROR: NULL REP!", ChannelChars_n.c_str());
	} else {
		ChannelChars->Dump(l_type, ChannelChars_n.c_str());
	}
}

PyRepTuple *ChannelCreateReply::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	if(ChannelInfo == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelInfo is NULL! hacking in a PyRepNone");
		ChannelInfo = new PyRepNone();
	}
	tuple0->items[0] = ChannelInfo->Clone();
	if(ChannelMods == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelMods is NULL! hacking in a PyRepNone");
		ChannelMods = new PyRepNone();
	}
	tuple0->items[1] = ChannelMods->Clone();
	if(ChannelChars == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelChars is NULL! hacking in a PyRepNone");
		ChannelChars = new PyRepNone();
	}
	tuple0->items[2] = ChannelChars->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *ChannelCreateReply::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	if(ChannelInfo == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelInfo is NULL! hacking in a PyRepNone");
		ChannelInfo = new PyRepNone();
	}
	tuple0->items[0] = ChannelInfo;
	ChannelInfo = NULL;
	if(ChannelMods == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelMods is NULL! hacking in a PyRepNone");
		ChannelMods = new PyRepNone();
	}
	tuple0->items[1] = ChannelMods;
	ChannelMods = NULL;
	if(ChannelChars == NULL) {
		_log(NET__PACKET_ERROR, "Encode ChannelCreateReply: ChannelChars is NULL! hacking in a PyRepNone");
		ChannelChars = new PyRepNone();
	}
	tuple0->items[2] = ChannelChars;
	ChannelChars = NULL;
	res = tuple0;
	

	return(res);
}

bool ChannelCreateReply::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool ChannelCreateReply::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode ChannelCreateReply failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode ChannelCreateReply failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	delete ChannelInfo;
	ChannelInfo = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	delete ChannelMods;
	ChannelMods = tuple0->items[1];
	tuple0->items[1] = NULL;
	
	delete ChannelChars;
	ChannelChars = tuple0->items[2];
	tuple0->items[2] = NULL;
	

	delete packet;
	return(true);
}

ChannelCreateReply *ChannelCreateReply::Clone() const {
	ChannelCreateReply *res = new ChannelCreateReply;
	res->CloneFrom(this);
	return(res);
}

void ChannelCreateReply::CloneFrom(const ChannelCreateReply *from) {
	delete ChannelInfo;
	if(from->ChannelInfo == NULL) {
		ChannelInfo = NULL;
	} else {
		ChannelInfo = from->ChannelInfo->Clone();
	}
	delete ChannelMods;
	if(from->ChannelMods == NULL) {
		ChannelMods = NULL;
	} else {
		ChannelMods = from->ChannelMods->Clone();
	}
	delete ChannelChars;
	if(from->ChannelChars == NULL) {
		ChannelChars = NULL;
	} else {
		ChannelChars = from->ChannelChars->Clone();
	}
	
}


Call_SendMessage::Call_SendMessage() {
	channelID = NULL;
	message = "";
}

Call_SendMessage::~Call_SendMessage() {
	delete channelID;
}

void Call_SendMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_SendMessage", pfx);
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL TUPLE!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	_log(l_type, "%smessage='%s'", pfx, message.c_str());
}

PyRepTuple *Call_SendMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_SendMessage: channelID is NULL! hacking in an empty tuple.");
		channelID = new PyRepTuple(0);
	}
	tuple0->items[0] = channelID->Clone();
	tuple0->items[1] = new PyRepString(message);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_SendMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_SendMessage: channelID is NULL! hacking in an empty tuple.");
		channelID = new PyRepTuple(0);
	}
	
	PyRepTuple *list1 = new PyRepTuple(0);
	list1->items = channelID->items;
	channelID->items.clear();
	tuple0->items[0] = list1;
	tuple0->items[1] = new PyRepString(message);
	res = tuple0;
	

	return(res);
}

bool Call_SendMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_SendMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SendMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_SendMessage failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_SendMessage failed: channelID is not a tuple: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	channelID = (PyRepTuple *) tuple0->items[0];
	tuple0->items[0] = NULL;
	
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_SendMessage failed: message is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[1];
	message = string_1->value;

	delete packet;
	return(true);
}

Call_SendMessage *Call_SendMessage::Clone() const {
	Call_SendMessage *res = new Call_SendMessage;
	res->CloneFrom(this);
	return(res);
}

void Call_SendMessage::CloneFrom(const Call_SendMessage *from) {
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->TypedClone();
	}
	message = from->message;
	
}


LSCChannelMultiDesc::LSCChannelMultiDesc() {
	type = "";
	number = 0;
}

LSCChannelMultiDesc::~LSCChannelMultiDesc() {
}

void LSCChannelMultiDesc::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sLSCChannelMultiDesc", pfx);
	_log(l_type, "%stype='%s'", pfx, type.c_str());
	_log(l_type, "%snumber=%lu", pfx, number);
}

PyRepTuple *LSCChannelMultiDesc::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepString(type);
	tuple1->items[1] = new PyRepInteger(number);
	tuple0->items[0] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *LSCChannelMultiDesc::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepString(type);
	tuple1->items[1] = new PyRepInteger(number);
	tuple0->items[0] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool LSCChannelMultiDesc::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool LSCChannelMultiDesc::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: tuple1 is the wrong size: expected 2, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: type is not a string: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple1->items[0];
	type = string_2->value;
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode LSCChannelMultiDesc failed: number is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple1->items[1];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode LSCChannelMultiDesc: truncating 64 bit into into 32 bit int for field number");
	}
	number = int_3->value;

	delete packet;
	return(true);
}

LSCChannelMultiDesc *LSCChannelMultiDesc::Clone() const {
	LSCChannelMultiDesc *res = new LSCChannelMultiDesc;
	res->CloneFrom(this);
	return(res);
}

void LSCChannelMultiDesc::CloneFrom(const LSCChannelMultiDesc *from) {
	type = from->type;
	number = from->number;
	
}


RspGetChannels::RspGetChannels() {
	/*  0  */
}

RspGetChannels::~RspGetChannels() {
	/*  0  */
}

void RspGetChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetChannels", pfx);
	/*  0  */
	_log(l_type, "%scachedcall:", pfx);
	std::string cachedcall_n(pfx);
	cachedcall_n += "    ";
	cachedcall.Dump(l_type, cachedcall_n.c_str());
}

PyRepTuple *RspGetChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = cachedcall.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = cachedcall.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!cachedcall.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetChannels failed: unable to decode element cachedcall");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetChannels *RspGetChannels::Clone() const {
	RspGetChannels *res = new RspGetChannels;
	res->CloneFrom(this);
	return(res);
}

void RspGetChannels::CloneFrom(const RspGetChannels *from) {
	/*  0  */
	cachedcall.CloneFrom(&from->cachedcall);
	
}


CallJoinChannels::CallJoinChannels() {
	/*  0  */
}

CallJoinChannels::~CallJoinChannels() {
	/*  0  */
}

void CallJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallJoinChannels", pfx);
	/*  0  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
}

PyRepTuple *CallJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	tuple0->items[0] = channels.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallJoinChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = channels.items;
	channels.items.clear();
	tuple0->items[0] = list1;
	res = tuple0;
	

	return(res);
}

bool CallJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallJoinChannels failed: channels is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) tuple0->items[0];	channels.items = list_channels->items;
	list_channels->items.clear();
	

	delete packet;
	return(true);
}

CallJoinChannels *CallJoinChannels::Clone() const {
	CallJoinChannels *res = new CallJoinChannels;
	res->CloneFrom(this);
	return(res);
}

void CallJoinChannels::CloneFrom(const CallJoinChannels *from) {
	/*  0  */
	channels.CloneFrom(&from->channels);
	
}


RspJoinChannels::RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

RspJoinChannels::~RspJoinChannels() {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
}

void RspJoinChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspJoinChannels", pfx);
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
}

PyRepTuple *RspJoinChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	ss_1 = channels.Clone();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspJoinChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	
	PyRepList *list2 = new PyRepList();
	list2->items = channels.items;
	channels.items.clear();
	ss_1 = list2;
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspJoinChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspJoinChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	if(!ss_1->decoded->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode RspJoinChannels failed: channels is not a list: %s", ss_1->decoded->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) ss_1->decoded;	channels.items = list_channels->items;
	list_channels->items.clear();
	

	delete packet;
	return(true);
}

RspJoinChannels *RspJoinChannels::Clone() const {
	RspJoinChannels *res = new RspJoinChannels;
	res->CloneFrom(this);
	return(res);
}

void RspJoinChannels::CloneFrom(const RspJoinChannels *from) {
	/*  0  */
	/*  list of complex elements, one for each requested channel
	    with details about the channel  */
	channels.CloneFrom(&from->channels);
	
}


OnLSC_SenderInfo::OnLSC_SenderInfo() {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	corpID = 0;
	/*  2: who (could be this list, or could be just an integer ID)  */
	senderID = 0;
	senderName = "";
	senderType = 0;
	/*  3: whoRole  */
	role = 0;
	/*  4: whoCorpRole  */
	corp_role = 0;
}

OnLSC_SenderInfo::~OnLSC_SenderInfo() {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	/*  2: who (could be this list, or could be just an integer ID)  */
	/*  3: whoRole  */
	/*  4: whoCorpRole  */
}

void OnLSC_SenderInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_SenderInfo", pfx);
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	_log(l_type, "%scorpID=%lu", pfx, corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssenderName='%s'", pfx, senderName.c_str());
	_log(l_type, "%ssenderType=%lu", pfx, senderType);
	/*  3: whoRole  */
	_log(l_type, "%srole=" I64u, pfx, role);
	/*  4: whoCorpRole  */
	_log(l_type, "%scorp_role=" I64u, pfx, corp_role);
}

PyRepTuple *OnLSC_SenderInfo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: whoAllianceID  */
	tuple0->items[0] = new PyRepNone();
	/*  1: whoCorpID  */
	tuple0->items[1] = new PyRepInteger(corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepInteger(senderID);
	list1->items[1] = new PyRepString(senderName);
	list1->items[2] = new PyRepInteger(senderType);
	tuple0->items[2] = list1;
	
	/*  3: whoRole  */
	tuple0->items[3] = new PyRepInteger(role);
	/*  4: whoCorpRole  */
	tuple0->items[4] = new PyRepInteger(corp_role);
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_SenderInfo::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: whoAllianceID  */
	tuple0->items[0] = new PyRepNone();
	/*  1: whoCorpID  */
	tuple0->items[1] = new PyRepInteger(corpID);
	/*  2: who (could be this list, or could be just an integer ID)  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepInteger(senderID);
	list1->items[1] = new PyRepString(senderName);
	list1->items[2] = new PyRepInteger(senderType);
	tuple0->items[2] = list1;
	
	/*  3: whoRole  */
	tuple0->items[3] = new PyRepInteger(role);
	/*  4: whoCorpRole  */
	tuple0->items[4] = new PyRepInteger(corp_role);
	res = tuple0;
	

	return(res);
}

bool OnLSC_SenderInfo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_SenderInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: whoAllianceID  */
	if(!tuple0->items[0]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: expecting a None but got a %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  1: whoCorpID  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: corpID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field corpID");
	}
	corpID = int_1->value;
	/*  2: who (could be this list, or could be just an integer ID)  */
	if(!tuple0->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: list2 is not a list: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) tuple0->items[2];
	if(list2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: list2 is the wrong size: expected 3, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderID is not an int: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderName is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	senderName = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: senderType is not an int: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) list2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SenderInfo: truncating 64 bit into into 32 bit int for field senderType");
	}
	senderType = int_5->value;
	/*  3: whoRole  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: role is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_6 = (PyRepInteger *) tuple0->items[3];
	role = int64_6->value;
	/*  4: whoCorpRole  */
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SenderInfo failed: corp_role is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_7 = (PyRepInteger *) tuple0->items[4];
	corp_role = int64_7->value;

	delete packet;
	return(true);
}

OnLSC_SenderInfo *OnLSC_SenderInfo::Clone() const {
	OnLSC_SenderInfo *res = new OnLSC_SenderInfo;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_SenderInfo::CloneFrom(const OnLSC_SenderInfo *from) {
	/*  0: whoAllianceID  */
	/*  1: whoCorpID  */
	corpID = from->corpID;
	/*  2: who (could be this list, or could be just an integer ID)  */
	senderID = from->senderID;
	senderName = from->senderName;
	senderType = from->senderType;
	/*  3: whoRole  */
	role = from->role;
	/*  4: whoCorpRole  */
	corp_role = from->corp_role;
	
}


NotifyOnLSC::NotifyOnLSC() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1: estimated member count  */
	member_count = 0;
	/*  2  */
	method = "";
	/*  3  */
	sender = NULL;
	/*  4  */
	arguments = NULL;
}

NotifyOnLSC::~NotifyOnLSC() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1: estimated member count  */
	/*  2  */
	/*  3  */
	delete sender;
	/*  4  */
	delete arguments;
}

void NotifyOnLSC::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnLSC", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1: estimated member count  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
	_log(l_type, "%sarguments:", pfx);
	std::string arguments_n(pfx);
	arguments_n += "    ";
	if(arguments == NULL) {
		_log(l_type, "%sERROR: NULL TUPLE!", arguments_n.c_str());
	} else {
		arguments->Dump(l_type, arguments_n.c_str());
	}
}

PyRepTuple *NotifyOnLSC::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1: estimated member count  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	tuple0->items[4] = arguments->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnLSC::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1: estimated member count  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	if(arguments == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnLSC: arguments is NULL! hacking in an empty tuple.");
		arguments = new PyRepTuple(0);
	}
	
	PyRepTuple *list1 = new PyRepTuple(0);
	list1->items = arguments->items;
	arguments->items.clear();
	tuple0->items[4] = list1;
	res = tuple0;
	

	return(res);
}

bool NotifyOnLSC::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnLSC::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1: estimated member count  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnLSC: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnLSC failed: arguments is not a tuple: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	arguments = (PyRepTuple *) tuple0->items[4];
	tuple0->items[4] = NULL;
	

	delete packet;
	return(true);
}

NotifyOnLSC *NotifyOnLSC::Clone() const {
	NotifyOnLSC *res = new NotifyOnLSC;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnLSC::CloneFrom(const NotifyOnLSC *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1: estimated member count  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	delete arguments;
	if(from->arguments == NULL) {
		arguments = NULL;
	} else {
		arguments = from->arguments->TypedClone();
	}
	
}


OnLSC_SendMessage::OnLSC_SendMessage() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "SendMessage";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
	/*  0  */
	message = "";
}

OnLSC_SendMessage::~OnLSC_SendMessage() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
	/*  0  */
}

void OnLSC_SendMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_SendMessage", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
	/*  0  */
	_log(l_type, "%smessage='%s'", pfx, message.c_str());
}

PyRepTuple *OnLSC_SendMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepString(message);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_SendMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_SendMessage: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepString(message);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_SendMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_SendMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_SendMessage: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: tuple4 is the wrong size: expected 1, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple4->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_SendMessage failed: message is not a string: %s", tuple4->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) tuple4->items[0];
	message = string_5->value;

	delete packet;
	return(true);
}

OnLSC_SendMessage *OnLSC_SendMessage::Clone() const {
	OnLSC_SendMessage *res = new OnLSC_SendMessage;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_SendMessage::CloneFrom(const OnLSC_SendMessage *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	/*  0  */
	message = from->message;
	
}


OnLSC_JoinChannel::OnLSC_JoinChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "JoinChannel";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
}

OnLSC_JoinChannel::~OnLSC_JoinChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
}

void OnLSC_JoinChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_JoinChannel", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
}

PyRepTuple *OnLSC_JoinChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_JoinChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_JoinChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_JoinChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_JoinChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_JoinChannel: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_JoinChannel failed: tuple4 is the wrong size: expected 0, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

OnLSC_JoinChannel *OnLSC_JoinChannel::Clone() const {
	OnLSC_JoinChannel *res = new OnLSC_JoinChannel;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_JoinChannel::CloneFrom(const OnLSC_JoinChannel *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	
}


OnLSC_DestroyChannel::OnLSC_DestroyChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "DestroyChannel";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
}

OnLSC_DestroyChannel::~OnLSC_DestroyChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
}

void OnLSC_DestroyChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_DestroyChannel", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
}

PyRepTuple *OnLSC_DestroyChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_DestroyChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_DestroyChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_DestroyChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_DestroyChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_DestroyChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_DestroyChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_DestroyChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_DestroyChannel: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_DestroyChannel failed: tuple4 is the wrong size: expected 0, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

OnLSC_DestroyChannel *OnLSC_DestroyChannel::Clone() const {
	OnLSC_DestroyChannel *res = new OnLSC_DestroyChannel;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_DestroyChannel::CloneFrom(const OnLSC_DestroyChannel *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	
}


OnLSC_LeaveChannel::OnLSC_LeaveChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	channelID = NULL;
	/*  1  */
	member_count = 0;
	/*  2  */
	method = "LeaveChannel";
	/*  3: sender info  */
	sender = NULL;
	/*  4  */
}

OnLSC_LeaveChannel::~OnLSC_LeaveChannel() {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	/*  1  */
	/*  2  */
	/*  3: sender info  */
	delete sender;
	/*  4  */
}

void OnLSC_LeaveChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnLSC_LeaveChannel", pfx);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	_log(l_type, "%schannelID:", pfx);
	std::string channelID_n(pfx);
	channelID_n += "    ";
	if(channelID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channelID_n.c_str());
	} else {
		channelID->Dump(l_type, channelID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%smember_count=%lu", pfx, member_count);
	/*  2  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
	/*  3: sender info  */
	_log(l_type, "%ssender:", pfx);
	std::string sender_n(pfx);
	sender_n += "    ";
	if(sender == NULL) {
		_log(l_type, "%sERROR: NULL OBJECT!", sender_n.c_str());
	} else {
		sender->Dump(l_type, sender_n.c_str());
	}
	/*  4  */
}

PyRepTuple *OnLSC_LeaveChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->Encode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnLSC_LeaveChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	if(channelID == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: channelID is NULL! hacking in a PyRepNone");
		channelID = new PyRepNone();
	}
	tuple0->items[0] = channelID;
	channelID = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(member_count);
	/*  2  */
	tuple0->items[2] = new PyRepString(method);
	/*  3: sender info  */
	if(sender == NULL) {
		_log(NET__PACKET_ERROR, "Encode OnLSC_LeaveChannel: sender is NULL! hacking in a PyRepNone");
		tuple0->items[3] = new PyRepNone();
	} else {
		tuple0->items[3] = sender->FastEncode();
	}
	/*  4  */
	PyRepTuple *tuple1 = new PyRepTuple(0);
	tuple0->items[4] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool OnLSC_LeaveChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnLSC_LeaveChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	channelID = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: member_count is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnLSC_LeaveChannel: truncating 64 bit into into 32 bit int for field member_count");
	}
	member_count = int_1->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: method is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[2];
	method = string_2->value;
	/*  3: sender info  */
	PyRep *rep_3 = tuple0->items[3];
	tuple0->items[3] = NULL;
	delete sender;
	sender = new OnLSC_SenderInfo;
	if(!sender->Decode(&rep_3)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: unable to decode element sender");
		delete packet;
		return(false);
	}
	
	/*  4  */
	if(!tuple0->items[4]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple4 is the wrong type: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) tuple0->items[4];
	if(tuple4->items.size() != 0) {
		_log(NET__PACKET_ERROR, "Decode OnLSC_LeaveChannel failed: tuple4 is the wrong size: expected 0, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}


	delete packet;
	return(true);
}

OnLSC_LeaveChannel *OnLSC_LeaveChannel::Clone() const {
	OnLSC_LeaveChannel *res = new OnLSC_LeaveChannel;
	res->CloneFrom(this);
	return(res);
}

void OnLSC_LeaveChannel::CloneFrom(const OnLSC_LeaveChannel *from) {
	/*  0: channel ID, either an int, or an LSCChannelMultiDesc   */
	delete channelID;
	if(from->channelID == NULL) {
		channelID = NULL;
	} else {
		channelID = from->channelID->Clone();
	}
	/*  1  */
	member_count = from->member_count;
	/*  2  */
	method = from->method;
	/*  3: sender info  */
	delete sender;
	if(from->sender == NULL) {
		sender = NULL;
	} else {
		sender = from->sender->Clone();
	}
	/*  4  */
	
}


CallLeaveChannels::CallLeaveChannels() {
	/*  0  */
	/*  1  */
	unsubscribe = 0;
}

CallLeaveChannels::~CallLeaveChannels() {
	/*  0  */
	/*  1  */
}

void CallLeaveChannels::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallLeaveChannels", pfx);
	/*  0  */
	_log(l_type, "%schannels: ", pfx);
	std::string channels_n(pfx);
	channels_n += "    ";
	channels.Dump(l_type, channels_n.c_str());
	/*  1  */
	_log(l_type, "%sunsubscribe=%lu", pfx, unsubscribe);
}

PyRepTuple *CallLeaveChannels::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = channels.Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallLeaveChannels::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = channels.items;
	channels.items.clear();
	tuple0->items[0] = list1;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

bool CallLeaveChannels::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallLeaveChannels::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: channels is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_channels = (PyRepList *) tuple0->items[0];	channels.items = list_channels->items;
	list_channels->items.clear();
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannels failed: unsubscribe is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallLeaveChannels: truncating 64 bit into into 32 bit int for field unsubscribe");
	}
	unsubscribe = int_1->value;

	delete packet;
	return(true);
}

CallLeaveChannels *CallLeaveChannels::Clone() const {
	CallLeaveChannels *res = new CallLeaveChannels;
	res->CloneFrom(this);
	return(res);
}

void CallLeaveChannels::CloneFrom(const CallLeaveChannels *from) {
	/*  0  */
	channels.CloneFrom(&from->channels);
	/*  1  */
	unsubscribe = from->unsubscribe;
	
}


CallLeaveChannel::CallLeaveChannel() {
	/*  0  */
	channel = NULL;
	/*  1  */
	unsubscribe = 0;
}

CallLeaveChannel::~CallLeaveChannel() {
	/*  0  */
	delete channel;
	/*  1  */
}

void CallLeaveChannel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallLeaveChannel", pfx);
	/*  0  */
	_log(l_type, "%schannel:", pfx);
	std::string channel_n(pfx);
	channel_n += "    ";
	if(channel == NULL) {
		_log(l_type, "%sERROR: NULL REP!", channel_n.c_str());
	} else {
		channel->Dump(l_type, channel_n.c_str());
	}
	/*  1  */
	_log(l_type, "%sunsubscribe=%lu", pfx, unsubscribe);
}

PyRepTuple *CallLeaveChannel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(channel == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallLeaveChannel: channel is NULL! hacking in a PyRepNone");
		channel = new PyRepNone();
	}
	tuple0->items[0] = channel->Clone();
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallLeaveChannel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	if(channel == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallLeaveChannel: channel is NULL! hacking in a PyRepNone");
		channel = new PyRepNone();
	}
	tuple0->items[0] = channel;
	channel = NULL;
	/*  1  */
	tuple0->items[1] = new PyRepInteger(unsubscribe);
	res = tuple0;
	

	return(res);
}

bool CallLeaveChannel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallLeaveChannel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	delete channel;
	channel = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallLeaveChannel failed: unsubscribe is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[1];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallLeaveChannel: truncating 64 bit into into 32 bit int for field unsubscribe");
	}
	unsubscribe = int_1->value;

	delete packet;
	return(true);
}

CallLeaveChannel *CallLeaveChannel::Clone() const {
	CallLeaveChannel *res = new CallLeaveChannel;
	res->CloneFrom(this);
	return(res);
}

void CallLeaveChannel::CloneFrom(const CallLeaveChannel *from) {
	/*  0  */
	delete channel;
	if(from->channel == NULL) {
		channel = NULL;
	} else {
		channel = from->channel->Clone();
	}
	/*  1  */
	unsubscribe = from->unsubscribe;
	
}


Call_Page::Call_Page() {
	subject = "";
	body = "";
}

Call_Page::~Call_Page() {
}

void Call_Page::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Page", pfx);
	_log(l_type, "%srecipients: Integer list with %d enetires", pfx, recipients.size());
	std::vector<uint32>::const_iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, recipients_index, *recipients_cur);
	}
	
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%sbody='%s'", pfx, body.c_str());
}

PyRepTuple *Call_Page::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepString(subject);
	tuple0->items[2] = new PyRepString(body);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Page::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	tuple0->items[1] = new PyRepString(subject);
	tuple0->items[2] = new PyRepString(body);
	res = tuple0;
	

	return(res);
}

bool Call_Page::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Page::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: recipients is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	recipients.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator recipients_cur, recipients_end;
	recipients_cur = list_1->items.begin();
	recipients_end = list_1->items.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		if(!(*recipients_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_Page failed: Element %d in list recipients is not an integer: %s", recipients_index, (*recipients_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*recipients_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_Page: truncating 64 bit into into 32 bit int for item %d in field recipients", recipients_index);
		}
		recipients.push_back(t->value);
	}

	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: subject is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	subject = string_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_Page failed: body is not a string: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple0->items[2];
	body = string_3->value;

	delete packet;
	return(true);
}

Call_Page *Call_Page::Clone() const {
	Call_Page *res = new Call_Page;
	res->CloneFrom(this);
	return(res);
}

void Call_Page::CloneFrom(const Call_Page *from) {
	recipients = from->recipients;
	subject = from->subject;
	body = from->body;
	
}


NotifyOnMessage::NotifyOnMessage() {
	/*  1: messageID: this might be a more complex type in the future.   */
	messageID = 0;
	senderID = 0;
	subject = "";
	sentTime = 0;
	/*  not sure _exactly_ what timestamp this should be  */
}

NotifyOnMessage::~NotifyOnMessage() {
	/*  1: messageID: this might be a more complex type in the future.   */
	/*  not sure _exactly_ what timestamp this should be  */
}

void NotifyOnMessage::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnMessage", pfx);
	_log(l_type, "%srecipients: Integer list with %d enetires", pfx, recipients.size());
	std::vector<uint32>::const_iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, recipients_index, *recipients_cur);
	}
	
	/*  1: messageID: this might be a more complex type in the future.   */
	_log(l_type, "%smessageID=%lu", pfx, messageID);
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%ssentTime=" I64u, pfx, sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
}

PyRepTuple *NotifyOnMessage::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1: messageID: this might be a more complex type in the future.   */
	tuple0->items[1] = new PyRepInteger(messageID);
	tuple0->items[2] = new PyRepInteger(senderID);
	tuple0->items[3] = new PyRepString(subject);
	tuple0->items[4] = new PyRepInteger(sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnMessage::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(5);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator recipients_cur, recipients_end;
	recipients_cur = recipients.begin();
	recipients_end = recipients.end();
	for(; recipients_cur != recipients_end; recipients_cur++) {
		list1->items.push_back(
			new PyRepInteger(*recipients_cur)
		);
	}
	tuple0->items[0] = list1;
	
	/*  1: messageID: this might be a more complex type in the future.   */
	tuple0->items[1] = new PyRepInteger(messageID);
	tuple0->items[2] = new PyRepInteger(senderID);
	tuple0->items[3] = new PyRepString(subject);
	tuple0->items[4] = new PyRepInteger(sentTime);
	/*  not sure _exactly_ what timestamp this should be  */
	res = tuple0;
	

	return(res);
}

bool NotifyOnMessage::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnMessage::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: tuple0 is the wrong size: expected 5, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: recipients is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	recipients.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator recipients_cur, recipients_end;
	recipients_cur = list_1->items.begin();
	recipients_end = list_1->items.end();
	int recipients_index;
	for(recipients_index = 0; recipients_cur != recipients_end; recipients_cur++, recipients_index++) {
		if(!(*recipients_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: Element %d in list recipients is not an integer: %s", recipients_index, (*recipients_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*recipients_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for item %d in field recipients", recipients_index);
		}
		recipients.push_back(t->value);
	}

	/*  1: messageID: this might be a more complex type in the future.   */
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: messageID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: senderID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnMessage: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_3->value;
	if(!tuple0->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: subject is not a string: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) tuple0->items[3];
	subject = string_4->value;
	if(!tuple0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnMessage failed: sentTime is not an int: %s", tuple0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_5 = (PyRepInteger *) tuple0->items[4];
	sentTime = int64_5->value;
	/*  not sure _exactly_ what timestamp this should be  */

	delete packet;
	return(true);
}

NotifyOnMessage *NotifyOnMessage::Clone() const {
	NotifyOnMessage *res = new NotifyOnMessage;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnMessage::CloneFrom(const NotifyOnMessage *from) {
	recipients = from->recipients;
	/*  1: messageID: this might be a more complex type in the future.   */
	messageID = from->messageID;
	senderID = from->senderID;
	subject = from->subject;
	sentTime = from->sentTime;
	/*  not sure _exactly_ what timestamp this should be  */
	
}


Call_DeleteMessages::Call_DeleteMessages() {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	channelID = 0;
}

Call_DeleteMessages::~Call_DeleteMessages() {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
}

void Call_DeleteMessages::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_DeleteMessages", pfx);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%smessages: Integer list with %d enetires", pfx, messages.size());
	std::vector<uint32>::const_iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	int messages_index;
	for(messages_index = 0; messages_cur != messages_end; messages_cur++, messages_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, messages_index, *messages_cur);
	}
	
}

PyRepTuple *Call_DeleteMessages::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	tuple0->items[0] = new PyRepInteger(channelID);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	for(; messages_cur != messages_end; messages_cur++) {
		list1->items.push_back(
			new PyRepInteger(*messages_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_DeleteMessages::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	tuple0->items[0] = new PyRepInteger(channelID);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator messages_cur, messages_end;
	messages_cur = messages.begin();
	messages_end = messages.end();
	for(; messages_cur != messages_end; messages_cur++) {
		list1->items.push_back(
			new PyRepInteger(*messages_cur)
		);
	}
	tuple0->items[1] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_DeleteMessages::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_DeleteMessages::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  most likely this could be an LSCChannelMultiDesc too...  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: channelID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_DeleteMessages: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: messages is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	messages.clear();
	PyRepList *list_2 = (PyRepList *) tuple0->items[1];
	PyRepList::iterator messages_cur, messages_end;
	messages_cur = list_2->items.begin();
	messages_end = list_2->items.end();
	int messages_index;
	for(messages_index = 0; messages_cur != messages_end; messages_cur++, messages_index++) {
		if(!(*messages_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_DeleteMessages failed: Element %d in list messages is not an integer: %s", messages_index, (*messages_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*messages_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_DeleteMessages: truncating 64 bit into into 32 bit int for item %d in field messages", messages_index);
		}
		messages.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_DeleteMessages *Call_DeleteMessages::Clone() const {
	Call_DeleteMessages *res = new Call_DeleteMessages;
	res->CloneFrom(this);
	return(res);
}

void Call_DeleteMessages::CloneFrom(const Call_DeleteMessages *from) {
	/*  most likely this could be an LSCChannelMultiDesc too...  */
	channelID = from->channelID;
	messages = from->messages;
	
}


Rsp_GetEVEMailDetails::Rsp_GetEVEMailDetails() {
	/*  first the actul message  */
	/* object of type util.Row */
	head_messageID = "messageID";
	head_senderID = "senderID";
	head_subject = "subject";
	head_body = "body";
	head_created = "created";
	head_mimeType = "mimeType";
	head_channelID = "channelID";
	head_deleted = "deleted";
	messageID = 0;
	senderID = 0;
	subject = "";
	body = "";
	created = 0;
	/*  mimeType is a nested row... silly CCP  */
	/* object of type util.Row */
	head_mimeTypeID = "mimeTypeID";
	head_mimeType2 = "mimeType";
	head_binary = "binary";
	mimeTypeID = 0;
	mimeType = "";
	binary = 0;
	channelID = 0;
	deleted = 0;
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
}

Rsp_GetEVEMailDetails::~Rsp_GetEVEMailDetails() {
	/*  first the actul message  */
	/*  mimeType is a nested row... silly CCP  */
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
}

void Rsp_GetEVEMailDetails::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetEVEMailDetails", pfx);
	/*  first the actul message  */
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_messageID='%s'", pfx, head_messageID.c_str());
	_log(l_type, "%shead_senderID='%s'", pfx, head_senderID.c_str());
	_log(l_type, "%shead_subject='%s'", pfx, head_subject.c_str());
	_log(l_type, "%shead_body='%s'", pfx, head_body.c_str());
	_log(l_type, "%shead_created='%s'", pfx, head_created.c_str());
	_log(l_type, "%shead_mimeType='%s'", pfx, head_mimeType.c_str());
	_log(l_type, "%shead_channelID='%s'", pfx, head_channelID.c_str());
	_log(l_type, "%shead_deleted='%s'", pfx, head_deleted.c_str());
	_log(l_type, "%smessageID=%lu", pfx, messageID);
	_log(l_type, "%ssenderID=%lu", pfx, senderID);
	_log(l_type, "%ssubject='%s'", pfx, subject.c_str());
	_log(l_type, "%sbody='%s'", pfx, body.c_str());
	_log(l_type, "%screated=" I64u, pfx, created);
	/*  mimeType is a nested row... silly CCP  */
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_mimeTypeID='%s'", pfx, head_mimeTypeID.c_str());
	_log(l_type, "%shead_mimeType2='%s'", pfx, head_mimeType2.c_str());
	_log(l_type, "%shead_binary='%s'", pfx, head_binary.c_str());
	_log(l_type, "%smimeTypeID=%lu", pfx, mimeTypeID);
	_log(l_type, "%smimeType='%s'", pfx, mimeType.c_str());
	_log(l_type, "%sbinary=%lu", pfx, binary);
	_log(l_type, "%schannelID=%lu", pfx, channelID);
	_log(l_type, "%sdeleted=%lu", pfx, deleted);
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	_log(l_type, "%sattachments:", pfx);
	std::string attachments_n(pfx);
	attachments_n += "    ";
	attachments.Dump(l_type, attachments_n.c_str());
}

PyRepTuple *Rsp_GetEVEMailDetails::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  first the actul message  */
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(8, NULL);
	list3->items[0] = new PyRepString(head_messageID);
	list3->items[1] = new PyRepString(head_senderID);
	list3->items[2] = new PyRepString(head_subject);
	list3->items[3] = new PyRepString(head_body);
	list3->items[4] = new PyRepString(head_created);
	list3->items[5] = new PyRepString(head_mimeType);
	list3->items[6] = new PyRepString(head_channelID);
	list3->items[7] = new PyRepString(head_deleted);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(8, NULL);
	list4->items[0] = new PyRepInteger(messageID);
	list4->items[1] = new PyRepInteger(senderID);
	list4->items[2] = new PyRepString(subject);
	list4->items[3] = new PyRepString(body);
	list4->items[4] = new PyRepInteger(created);
	/*  mimeType is a nested row... silly CCP  */
	PyRep *args5;
	PyRepDict *dict6 = new PyRepDict();
	PyRep *dict6_0;
	PyRepList *list7 = new PyRepList();
	list7->items.resize(3, NULL);
	list7->items[0] = new PyRepString(head_mimeTypeID);
	list7->items[1] = new PyRepString(head_mimeType2);
	list7->items[2] = new PyRepString(head_binary);
	dict6_0 = list7;
	
	dict6->items[
		new PyRepString("header")
	] = dict6_0;
	PyRep *dict6_1;
	PyRepList *list8 = new PyRepList();
	list8->items.resize(3, NULL);
	list8->items[0] = new PyRepInteger(mimeTypeID);
	list8->items[1] = new PyRepString(mimeType);
	list8->items[2] = new PyRepInteger(binary);
	dict6_1 = list8;
	
	dict6->items[
		new PyRepString("line")
	] = dict6_1;
	args5 = dict6;
	
	list4->items[5] = new PyRepObject(
			"util.Row",
			args5
		);
	
	list4->items[6] = new PyRepInteger(channelID);
	list4->items[7] = new PyRepInteger(deleted);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
		tuple0->items[1] = attachments.Encode();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Rsp_GetEVEMailDetails::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  first the actul message  */
	PyRep *args1;
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(8, NULL);
	list3->items[0] = new PyRepString(head_messageID);
	list3->items[1] = new PyRepString(head_senderID);
	list3->items[2] = new PyRepString(head_subject);
	list3->items[3] = new PyRepString(head_body);
	list3->items[4] = new PyRepString(head_created);
	list3->items[5] = new PyRepString(head_mimeType);
	list3->items[6] = new PyRepString(head_channelID);
	list3->items[7] = new PyRepString(head_deleted);
	dict2_0 = list3;
	
	dict2->items[
		new PyRepString("header")
	] = dict2_0;
	PyRep *dict2_1;
	PyRepList *list4 = new PyRepList();
	list4->items.resize(8, NULL);
	list4->items[0] = new PyRepInteger(messageID);
	list4->items[1] = new PyRepInteger(senderID);
	list4->items[2] = new PyRepString(subject);
	list4->items[3] = new PyRepString(body);
	list4->items[4] = new PyRepInteger(created);
	/*  mimeType is a nested row... silly CCP  */
	PyRep *args5;
	PyRepDict *dict6 = new PyRepDict();
	PyRep *dict6_0;
	PyRepList *list7 = new PyRepList();
	list7->items.resize(3, NULL);
	list7->items[0] = new PyRepString(head_mimeTypeID);
	list7->items[1] = new PyRepString(head_mimeType2);
	list7->items[2] = new PyRepString(head_binary);
	dict6_0 = list7;
	
	dict6->items[
		new PyRepString("header")
	] = dict6_0;
	PyRep *dict6_1;
	PyRepList *list8 = new PyRepList();
	list8->items.resize(3, NULL);
	list8->items[0] = new PyRepInteger(mimeTypeID);
	list8->items[1] = new PyRepString(mimeType);
	list8->items[2] = new PyRepInteger(binary);
	dict6_1 = list8;
	
	dict6->items[
		new PyRepString("line")
	] = dict6_1;
	args5 = dict6;
	
	list4->items[5] = new PyRepObject(
			"util.Row",
			args5
		);
	
	list4->items[6] = new PyRepInteger(channelID);
	list4->items[7] = new PyRepInteger(deleted);
	dict2_1 = list4;
	
	dict2->items[
		new PyRepString("line")
	] = dict2_1;
	args1 = dict2;
	
	tuple0->items[0] = new PyRepObject(
			"util.Row",
			args1
		);
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
		tuple0->items[1] = attachments.FastEncode();
	res = tuple0;
	

	return(res);
}

bool Rsp_GetEVEMailDetails::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetEVEMailDetails::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  first the actul message  */
	if(!tuple0->items[0]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_1 = (PyRepObject *) tuple0->items[0];
	
	if(obj_1->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_1 is the wrong object type. Expected 'util.Row', got '%s'", obj_1->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_1->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: dict2 is the wrong type: %s", obj_1->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_not_used1 = false;
	bool dict2_not_used2 = false;
	PyRepDict *dict2 = (PyRepDict *) obj_1->arguments;
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict2_not_used1 = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list3 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list3 = (PyRepList *) dict2_cur->second;
	if(list3->items.size() != 8) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list3 is the wrong size: expected 8, but got %d", list3->items.size());
		delete packet;
		return(false);
	}

	if(!list3->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_messageID is not a string: %s", list3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list3->items[0];
	head_messageID = string_4->value;
	if(!list3->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_senderID is not a string: %s", list3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list3->items[1];
	head_senderID = string_5->value;
	if(!list3->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_subject is not a string: %s", list3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list3->items[2];
	head_subject = string_6->value;
	if(!list3->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_body is not a string: %s", list3->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list3->items[3];
	head_body = string_7->value;
	if(!list3->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_created is not a string: %s", list3->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list3->items[4];
	head_created = string_8->value;
	if(!list3->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeType is not a string: %s", list3->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list3->items[5];
	head_mimeType = string_9->value;
	if(!list3->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_channelID is not a string: %s", list3->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list3->items[6];
	head_channelID = string_10->value;
	if(!list3->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_deleted is not a string: %s", list3->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list3->items[7];
	head_deleted = string_11->value;
		} else
		if(key_string__->value == "line") {
			dict2_not_used2 = true;
	if(!dict2_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list12 is not a list: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list12 = (PyRepList *) dict2_cur->second;
	if(list12->items.size() != 8) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list12 is the wrong size: expected 8, but got %d", list12->items.size());
		delete packet;
		return(false);
	}

	if(!list12->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: messageID is not an int: %s", list12->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) list12->items[0];
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field messageID");
	}
	messageID = int_13->value;
	if(!list12->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: senderID is not an int: %s", list12->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_14 = (PyRepInteger *) list12->items[1];
	if(int_14->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field senderID");
	}
	senderID = int_14->value;
	if(!list12->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: subject is not a string: %s", list12->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_15 = (PyRepString *) list12->items[2];
	subject = string_15->value;
	if(!list12->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: body is not a string: %s", list12->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_16 = (PyRepString *) list12->items[3];
	body = string_16->value;
	if(!list12->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: created is not an int: %s", list12->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_17 = (PyRepInteger *) list12->items[4];
	created = int64_17->value;
	/*  mimeType is a nested row... silly CCP  */
	if(!list12->items[5]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_18 is the wrong type: %s", list12->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_18 = (PyRepObject *) list12->items[5];
	
	if(obj_18->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: obj_18 is the wrong object type. Expected 'util.Row', got '%s'", obj_18->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_18->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: dict19 is the wrong type: %s", obj_18->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict19_not_used3 = false;
	bool dict19_not_used4 = false;
	PyRepDict *dict19 = (PyRepDict *) obj_18->arguments;
	
	PyRepDict::iterator dict19_cur, dict19_end;
	dict19_cur = dict19->items.begin();
	dict19_end = dict19->items.end();
	for(; dict19_cur != dict19_end; dict19_cur++) {
		PyRep *key__ = dict19_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: a key in dict19 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict19_not_used3 = true;
	if(!dict19_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list20 is not a list: %s", dict19_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list20 = (PyRepList *) dict19_cur->second;
	if(list20->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list20 is the wrong size: expected 3, but got %d", list20->items.size());
		delete packet;
		return(false);
	}

	if(!list20->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeTypeID is not a string: %s", list20->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_21 = (PyRepString *) list20->items[0];
	head_mimeTypeID = string_21->value;
	if(!list20->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_mimeType2 is not a string: %s", list20->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_22 = (PyRepString *) list20->items[1];
	head_mimeType2 = string_22->value;
	if(!list20->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: head_binary is not a string: %s", list20->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_23 = (PyRepString *) list20->items[2];
	head_binary = string_23->value;
		} else
		if(key_string__->value == "line") {
			dict19_not_used4 = true;
	if(!dict19_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list24 is not a list: %s", dict19_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list24 = (PyRepList *) dict19_cur->second;
	if(list24->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: list24 is the wrong size: expected 3, but got %d", list24->items.size());
		delete packet;
		return(false);
	}

	if(!list24->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: mimeTypeID is not an int: %s", list24->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_25 = (PyRepInteger *) list24->items[0];
	if(int_25->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field mimeTypeID");
	}
	mimeTypeID = int_25->value;
	if(!list24->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: mimeType is not a string: %s", list24->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_26 = (PyRepString *) list24->items[1];
	mimeType = string_26->value;
	if(!list24->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: binary is not an int: %s", list24->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_27 = (PyRepInteger *) list24->items[2];
	if(int_27->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field binary");
	}
	binary = int_27->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Unknown key string '%s' in dict19", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict19_not_used3) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used3' in dict19");
		delete packet;
		return(false);
	}
	
	if(!dict19_not_used4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used4' in dict19");
		delete packet;
		return(false);
	}
	
	if(!list12->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: channelID is not an int: %s", list12->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_28 = (PyRepInteger *) list12->items[6];
	if(int_28->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field channelID");
	}
	channelID = int_28->value;
	if(!list12->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: deleted is not an int: %s", list12->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_29 = (PyRepInteger *) list12->items[7];
	if(int_29->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetEVEMailDetails: truncating 64 bit into into 32 bit int for field deleted");
	}
	deleted = int_29->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_not_used1) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used1' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_not_used2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: Missing dict entry for 'not_used2' in dict2");
		delete packet;
		return(false);
	}
	
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	PyRep *rep_30 = tuple0->items[1];
	tuple0->items[1] = NULL;
	if(!attachments.Decode(&rep_30)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetEVEMailDetails failed: unable to decode element attachments");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetEVEMailDetails *Rsp_GetEVEMailDetails::Clone() const {
	Rsp_GetEVEMailDetails *res = new Rsp_GetEVEMailDetails;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetEVEMailDetails::CloneFrom(const Rsp_GetEVEMailDetails *from) {
	/*  first the actul message  */
	/* object of type util.Row */
	head_messageID = from->head_messageID;
	head_senderID = from->head_senderID;
	head_subject = from->head_subject;
	head_body = from->head_body;
	head_created = from->head_created;
	head_mimeType = from->head_mimeType;
	head_channelID = from->head_channelID;
	head_deleted = from->head_deleted;
	messageID = from->messageID;
	senderID = from->senderID;
	subject = from->subject;
	body = from->body;
	created = from->created;
	/*  mimeType is a nested row... silly CCP  */
	/* object of type util.Row */
	head_mimeTypeID = from->head_mimeTypeID;
	head_mimeType2 = from->head_mimeType2;
	head_binary = from->head_binary;
	mimeTypeID = from->mimeTypeID;
	mimeType = from->mimeType;
	binary = from->binary;
	channelID = from->channelID;
	deleted = from->deleted;
	/*  then any attachments. this is a util.Rowset  */
	/*  this might not work due to a type1 string issue in rowclass here,
      if that is the case, then change this over to a <list> temporarily  */
	attachments.CloneFrom(&from->attachments);
	
}


Call_LookupStringInt::Call_LookupStringInt() {
	searchString = "";
	searchOption = 0;
}

Call_LookupStringInt::~Call_LookupStringInt() {
}

void Call_LookupStringInt::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_LookupStringInt", pfx);
	_log(l_type, "%ssearchString='%s'", pfx, searchString.c_str());
	_log(l_type, "%ssearchOption=%lu", pfx, searchOption);
}

PyRepTuple *Call_LookupStringInt::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(searchString);
	tuple0->items[1] = new PyRepInteger(searchOption);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_LookupStringInt::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepString(searchString);
	tuple0->items[1] = new PyRepInteger(searchOption);
	res = tuple0;
	

	return(res);
}

bool Call_LookupStringInt::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_LookupStringInt::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: searchString is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	searchString = string_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupStringInt failed: searchOption is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_LookupStringInt: truncating 64 bit into into 32 bit int for field searchOption");
	}
	searchOption = int_2->value;

	delete packet;
	return(true);
}

Call_LookupStringInt *Call_LookupStringInt::Clone() const {
	Call_LookupStringInt *res = new Call_LookupStringInt;
	res->CloneFrom(this);
	return(res);
}

void Call_LookupStringInt::CloneFrom(const Call_LookupStringInt *from) {
	searchString = from->searchString;
	searchOption = from->searchOption;
	
}


Call_LookupIntString::Call_LookupIntString() {
	searchOption = 0;
	searchString = "";
}

Call_LookupIntString::~Call_LookupIntString() {
}

void Call_LookupIntString::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_LookupIntString", pfx);
	_log(l_type, "%ssearchOption=%lu", pfx, searchOption);
	_log(l_type, "%ssearchString='%s'", pfx, searchString.c_str());
}

PyRepTuple *Call_LookupIntString::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(searchOption);
	tuple0->items[1] = new PyRepString(searchString);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_LookupIntString::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(searchOption);
	tuple0->items[1] = new PyRepString(searchString);
	res = tuple0;
	

	return(res);
}

bool Call_LookupIntString::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_LookupIntString::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: searchOption is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_LookupIntString: truncating 64 bit into into 32 bit int for field searchOption");
	}
	searchOption = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_LookupIntString failed: searchString is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	searchString = string_2->value;

	delete packet;
	return(true);
}

Call_LookupIntString *Call_LookupIntString::Clone() const {
	Call_LookupIntString *res = new Call_LookupIntString;
	res->CloneFrom(this);
	return(res);
}

void Call_LookupIntString::CloneFrom(const Call_LookupIntString *from) {
	searchOption = from->searchOption;
	searchString = from->searchString;
	
}



